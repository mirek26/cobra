\chapter{General model}

\section{Notation and Terminology}
Let $\Form_\Var$ be the set of all prepositional formulas over
  the set of variables $\Var$;
  $\Val_\Var$ be the set of all valuations (boolean interpretation)
  of variables $\Var$.
Formulas $\form_0, \form_1 \in \Form_\Var$ are (semantically) equivalent,
  written $\form_0 \equiv \form_1$, if
  $\val(\form_0) = \val(\form_1)$ for all $\val\in\Val_\Var$.
We say that \emph{$\val$ is a model of $\form$}
  or that \emph{$\val$ satisfies $\form$}
  if $\val(\form) = 1$.

% In the whole text, we want to identify equivalent formulas.
% Therefore, let $\Form_\Var = \Form^*_\Var/\!\!\equiv$ and in the sequel,
%   let us identify a formula with its corresponding equivalence class.


For a formula $\form\in\Form_\Var$, let
  $\numval_\Var{\form} = |\{ \val\in\Val_\Var \| \val(\form) = 1 \}|$
  be the number of models of $\form$ (valuations satisfying $\form$).
%This definition is correct as equivalent formulas has same number of models.
We often omit the index $\Var$ if it is clear from the context.

% For any unary predicate $P$, $\#i\in A.P(i) = |\{ i\in A \| P(i)\}|$.
%   We often omit the ``$\in A$'' part and write only $\#i.P(i)$
%   if the range of $i$ is clear from the context.

The set of all permutations of a set $\Var$ (bijections $\Var->\Var$)
  is denoted by $\Perm_\Var$ and
  $\idperm_\Var$ is the identity permutation.

%-------------------------------------------------------------------------------
% DEF: CODE BREAKING GAME
\section{Formal definition}

Code breaking games are game between two players -- a \emph{codemaker}
  and a \emph{codebreaker}.
The codemaker selects a secret code and then evaluates the experiments
  performed by the codebreaker.
The codebreaker chooses and performs experiments and collects partial
  information about the code according to some rules.
The codebreaker strives to reveal the code in minimal number of experiments.
... (introduction)

Within the framework of propositional logic,
  we represent the secret code as a valuation
  of propositional variables.
The game can be represented as a \emph{set of variables},
  \emph{initial restriction} (a formula that is guaranteed to be satisfied),
  and a set of \emph{possible experiments}.
A finite set of possible \emph{outcomes} is associated with each experiment.
Outcome is a propositional formula that represents the partial information,
  which the codebreaker can gain from the experiment.

The number of experiments is typically very large
  (such as 36894 for the Counterfeit-coin Problem \ref{prob-coins})
  but most of them have same structure and yield similar outcomes.
Therefore we opt for a compact representation of an experiment as a pair
  (type of experiment, parametrization), where parametrization is a string
  over a defined alphabet.
This whole idea is formalized below.

\begin{definition}[Code Breaking Game] \label{def-game}
A \emph{Code Breaking Game} is a septuple
  $\game = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$, where
  \begin{itemize}
  \item $\Var$ is a finite set of propositional variables,
  \item $\init \in \Form_\Var$ is a satisfiable prepositional formula,
  \item $\Expt$ is a finite set of types of experiments,
  \item $\Sigma$ is a finite alphabet,
  \item $\Exp \subseteq \Expt \times \Sigma^\star$ is an \emph{experiment} relation,
  and
  \item $F$ is a finite collection of functions of type $\Sigma -> \Var$,
  \item $\outcome: \Expt -> 2^{\PForm_{\Var,F,\Sigma}}$ is an
  \emph{outcome function} such that $\outcome(\expt)$ is finite
  for any $\expt\in\Expt$. Definition of $\PForm$ follows (Definition \ref{def-pform}).
  \end{itemize}
\end{definition}

\begin{definition}[Parametrized formula] \label{def-pform}
A set of \emph{parametrized formulas} $\PForm_{\Var,F,\Sigma}$ is a set of
 all strings $\pform$ generated by the following grammar:
$$ \pform ::= x \| f(\$n) \| \pform \circ \pform \| \neg \pform,$$
where $x\in\Var$, $f\in F$, $n \in\Nset$, and $\circ\in\{\wedge, \vee, =>\}$.
By $\pform(\param)$ we denote application of a parametrization $\param\in\Sigma^\star$
on a formula $\pform$, which is defined recursively on the structure of $\pform$ in the following way:
\begin{align}
(x)(\param) &= x, \\
(f(\$n))(\param) &= f(\param[n]),\\
(\pform_1\circ\pform_2)(\param) &= \pform_1(\param) \circ \pform_2(\param),\\
(\neg\pform)(\param) &= \neg(\pform(\param)).
\end{align}
\end{definition}

We use the special symbol $\$$ in $f(\$n)$ so that $n$ cannot be mistaken for
  the argument of $f$, which is $n$-th symbol of the parametrization.
Note that if $f(\$n)$ apperas in $\pform$ and $|\param|<n$, then
  $\pform(\param)$ is undefined. \TODO{Or false? Does it matter? ...}

For the sake of simplicity, let us denote the set of possible outcomes for
  an experiment $\exp = (\expt, \param) \in \Exp$ by
  $\outcome(\exp) = \{ \pform(\param) \| \pform\in\outcome(\expt)\}$.

The compact representation with parametrized formulas does not restrict
  the class of games that can fit this definition.
If no two experiments
  can be united under the same type, every experiment can have its own type and
  allow only one possible parametrization.

\begin{definition}[Solving process]
An \emph{evaluated experiment} is a pair $(e, \form)$ such that $\form\in\outcome(e)$.
Let us denote the set of evaluated experiments by $\Omega$.

A \emph{solving process} is a finite or infinite sequence of evaluated experiments.
\end{definition}

For simplicity, we omit the brackets around the pairs and write
  \[
  \proc = \exp_1, \form_1, \exp_2, \form_2, ...
  \]
We use the notation $\proc(i) = \exp_i$ and $\proc[i] = \form_i$
  to refer to the $i$-th experiment and $i$-th formula, respectively.
For $k\in\Nseto$, $k <= |\proc|$ we denote by
  $\aknow{\proc}{k} = \form_0 \wedge \form_1 \wedge ... \wedge \form_k$
  the accrued knowledge after $k$ experiments.

\TODO{Update:} Let us now describe the course of the game in the defined terms.
First, the codemaker choose a valuation $\val$ of $\Var$
  which satisfies $\init$.
Then, the codebreaker successively chooses a type $\expt\in\Expt$ and
  a parametrization $\param\in\Sigma^*$ such that $(\expt, \param)\in\Exp$.
The codemaker gives the codebreaker a formula $\form\in\outcome((\expt, \param))$
  which is satisfied by the valuation $\val$.

Here we hit a problem -- so that the codemaker can always fulfill the last step,
  there must be a formula $\form\in\outcome(\exp)$ satisfied by any valuation.
Since it might make sense to allow multiple satisfied formulas, we restrict
  ourselves to game where the outcome is uniquely defined for given valuation.

\begin{definition}[Well-formed game] \label{def-wellformed}
A code-breaking game is \emph{well-formed} if for all $\exp \in \Exp$,
\begin{equation}
\forall\val\in\Val_\Var:
  \val(\init) = 1 ==> \exists \textrm{ exactly one }
     \form\in\outcome(\exp)\;.\; \val(\form) = 1
\end{equation}
\end{definition}

In sequel, we suppose a game to be well-formed, if not stated otherwise.
Note that this property is not easy to check.

%-------------------------------------------------------------------------------
% EXAMPLE: FAKE-COIN PROBLEM

\begin{example}[Fake-coin problem] \label{form-fake-coin1}
Fake-coin problem with $n$ coins, one of which is fake, can be formalized as
a code breaking game
$\mathcal{F}_n = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$.

\begin{itemize}
\item
$\Var = \{x_1, x_2, ..., x_n, y\}$, \\
$\init = \exactly{1}\{x_1, ..., x_n\}$. \\
Intuitively, variable $x_i$ tells weather the coin $i$ is fake.
Variable $y$ tells weather it is lighter or heavier.
Formula $\init$ says that exactly one coin is fake.

\item
$\Expt = \{ w_2, w_4, ..., w_n \}$, \\
$\Sigma = \{1, 2,...,n\}$, \\
$\Exp = \bigcup_{1<=m<=n/2} \{ (w_{2m}, \param) \|
  \param \in \{1,...,n\}^{2m}, \forall x\in\Var. \#_x(\param)<=1 \}. $\\
There are $n/2$ types of experiment -- according to the number of coins we put on the weights.
The alphabet contains natural numbers up to $n$ and
possible parametrizations for $w_{2m}$ are strings of length $2m$ with no repetitions.

\item
$F = \{ f_x \}$, where $f_x(i) = x_i$ for $1 <= i <= n$, \\
$\outcome(w_m) = $ \vspace{-3mm}
\begin{align*}
  \big\{
& ((f_x(\$1) \vee ... \vee f_x(\$m)) \wedge \neg y) \vee ((f_x(\$m+1) \vee ... \vee f_x(\$2m)) \wedge y), \\
& ((f_x(\$1) \vee ... \vee f_x(\$m)) \wedge y) \vee ((f_x(\$m+1) \vee ... \vee f_x(\$2m)) \wedge \neg y), \\
& \neg (f_x(\$1) \vee ... \vee f_x(\$2m)) \big\}.
\end{align*}
There are 3 possible outcomes of every experiment.
First, the right side is heavier. This happens if the fake coin is lighter and it appears in the first half of the parametrization, or if it is heavier and it appears in the second half. Second, analogously, the left side is heavier.
Third, the weights are balanced if the fake coin do not participate in the experiment.
\end{itemize}
\end{example}

%-------------------------------------------------------------------------------
% EXAMPLE: FAKE-COIN PROBLEM - alternative

\begin{example}[Fake-coin problem, alternative] \label{form-fake-coin2}
For demonstration purposes, here is another formalization of the same problem.
$\mathcal{F'}_n = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$.

\begin{itemize}
\item
$\Var = \{x_1, x_2, ..., x_n, y_1, y_2, ..., y_n\}$, \\
$\init = \exactly{1}\{x_1, ..., x_n, y_1, ..., y_n \}$. \\
Variable $x_i$ tells that the coin $i$ is lighter, variable $y_i$ tells that the coin $i$ is heavier.
Formule $\init$ says that exactly one coin is different.

\item
$\Expt, \Sigma, \Exp$ is defined as in Example \ref{form-fake-coin1}.

\item
$F = \{ f_x, f_y \}$, where $f_x(i) = x_i$ and $f_y(i) = y_i$ for $1 <= i <= n$, \vspace{-1.5mm}
\begin{flalign*}
\outcome(w_m) = \big\{ & (f_x(\$1) \vee ... \vee f_x(\$m)) \vee (f_y(\$m+1) \vee ... \vee f_y(\$2m)), & \\
& (f_y(\$1) \vee ... \vee f_y(\$m)) \vee (f_x(\$m+1) \vee ... \vee f_x(\$2m)), & \\
& \neg (f_x(\$1) \vee ... \vee f_x(\$2m) \vee f_y(\$1) \vee ... \vee f_y(\$2m)) \big\}. &
\end{flalign*}
\end{itemize}
\end{example}

%-------------------------------------------------------------------------------
% EXAMPLE: MASTERMIND

\begin{example}[Mastermind] \label{form-mastermind}
Mastermind puzzle with $n$ pegs and $m$ colors can be formalized as
a code breaking game
$\mathcal{M}_{n,m} = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$.

\begin{itemize}
\item
$\Var = \{x_{i,j} \| 1<=i<=n, 1<=j<=m \}$, \\
$\init = \bigwedge\left\{
  \exactly{1} \{x_{i,j} \| 1<=j<=m\} \| 1<=i<=n\right\}$. \\
Variable $x_{i,j}$ tells whether there is the color $j$ at position $i$.
Formula $\init$ says that there is exactly one color at each position.

\item
$\Expt = \{ g_{k_1,...,k_m} \| k_i \in \{1,...,n\}, \sum_ik_i = n \}$,\\
$\Sigma = C$, \\
$\Exp = \{(g_{k_1,...,k_m}, \param) \| \param\in\Sigma^{n}, \#i.(\param[i]=j)=k_j\}$.\\
The type $g_{k_1,...,k_m}$ covers all the guesses in which the number of $j$-colored pegs is $k_j$.
Therefore, two guesses for which we use the same pegs (pegs are just shuffled) are of the same type,
but if we change a peg for one with different color, it is other type of experiment.

\item
$F = \{ f_1, ..., f_n \}$, where $f_i(c) = x_{i,c}$ for $1<=i<=n$,
\vspace{-2mm}
\begin{flalign*}
\outcome(& g_{k_1,...,k_n}) =  \Big\{ &\\
 & \exactly{b}\{ f_i(\$i) \| 1<=i<=n \} \;\wedge &\\
 & \exactly{t}\bigcup
      \big\{
           \{ \atleast{l}(x_{1,j},...,x_{n,j}) \| 1 <= l <= k_j \}
           \| 1<=j<=m
      \big\} &\\
  &\hspace{2cm} \| 0<=b<=t, 0<=t<=n\Big\}.
\end{flalign*}
\TODO{Zdůvodnit proč to funguje.}
\end{itemize}
\end{example}

%-------------------------------------------------------------------------------
% EXAMPLE: MASTERMIND 2

\begin{example}[Mastermind (alternative)] \label{form-mastermind2}
$\mathcal{M'}_{n,m} = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$.

\begin{itemize}
\item
$\Var$ and $\init$ is defined as in Example \ref{form-mastermind}. \\

\item
$\Expt = \{ g \}$,\\
$\Sigma = C$, \\
$\Exp = \{(g, \param) \| \param\in\Sigma^{n}\}$.\\

\item
$F = \{ f_1, ..., f_n \}$, where $f_i(c) = x_{i,c}$ for $1<=i<=n$,
$\outcome(g) = \{ \textrm{Outcome}(b, w) \| 0<=b<=n, 0<=w<=n, b+w<=n \}$,
where $\textrm{Outcome}$ function is computed by the algorithm described below.
\end{itemize}

\newcommand{\BlackSymb}{\bullet}
\newcommand{\NoSymb}{\times}

Consider a fixed color combination (code) and a guess.
We assign a symbol $\BlackSymb$, $\NoSymb$ or a number to each position
  in the following way.
If the color at a position is same in the code and the guess, we assign
  $\BlackSymb$ to this position and the player gets a black peg for it.
If the color in the guess at position $i$ differs but it appears
  appears at position $j$ in the code, we assign $j$ to position $i$ and
  the player gets a white peg. Also, position $j$ must not be assigned
  $\BlackSymb$ and the number $j$ must not be assigned to any other position.
We assign $\NoSymb$ to all other positions.
For example, if the code is $1234$ and the guess is $5251$, the assignment is
 $\underline{\NoSymb\BlackSymb\NoSymb\:1}$.

We start the computation of Outcome$(b, w)$ with generation of
  all combinations of $\BlackSymb$, $\NoSymb$ and different numbers from $1$ to
  $n$,
  so that there is $b$-times $\BlackSymb$, $w$-times a number and
  no number refers to a position with $\BlackSymb$.

Next, for each combination, we generate a conjunction in the following way:
\begin{itemize}
\item For $\BlackSymb$ at position $i$, we add $f_i(\$i)$.
\item For a number $j$ at position $i$, we add $\neg f_i(\$i) \wedge f_j(\$i)$.
\item For $\NoSymb$ at position $i$, we add $\neg f_j(\$i)$ for any other position $j$ with $\NoSymb$.
\end{itemize}
The result is a disjunction of all these clauses, which effectively enumerates all the cases.

To get a better idea about the results, this is $\textrm{Outcome}(1, 1)$ for n = 4:

...
% \medskip
% \begin{scriptsize}$(
% \neg f_0(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_0(\$2) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_0(\$2) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_2(\$0) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_1(\$1) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
% (\neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_3(\$1) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_2(\$2) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_1(\$1) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_1(\$3) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_1(\$3) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_3(\$0) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_0(\$3) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_0(\$3) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_1(\$1) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_3(\$0) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
% (\neg f_0(\$0) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_0(\$3) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_0(\$3) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_2(\$2) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
% (\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)
% ).$
% \end{scriptsize} \medskip

However complicated this may look, note that it is not much different from
 the previous model where the complexity of the formulas was hidden in the
 Exactly and AtLeast macro operators.
\end{example}

We do not provide the formal definition of other Code breaking Games presented in
  Chapter \ref{ch-games}.
However, a computer language for game specification
  that is based on this formalism is introduced in Chapter \ref{ch-cobra}, and
  definition of all the games in this language can be found in Appendix \ref{app-games}.

%-------------------------------------------------------------------------------
% DEF: STRATEGY
\section{Strategies}

\begin{definition}[Strategy]
A \emph{strategy} is a function $\stg: \Omega^* -> \Exp$,
  determining the next experiment for a given finite solving process.
\end{definition}

A strategy $\stg$ together with a valuation $\val$ (satisfying $\form_0$)
  induce an infinite solving process
  \[
  \procstg{\stg}{\val} = \exp_1, \form_1, \exp_2, \form_2, ...,
  \]
  where
  $\exp_{i+1} = \stg(\exp_1, \form_1, ..., \exp_i, \form_i)$
  and
  $\form_{i+1} \in \outcome(\exp_{i+1})$
  is such that
  $\val(\form_{i+1}) = 1$,
  for all $i\in\Nset$.
Notice that due to the condition in Definition \ref{def-wellformed},
  there is always exactly one such $\form_{i+1}$.
We denote the knowledge accrued by $\stg$ on $\val$ after $k$ experiments
  by $\stgknow{\stg}{\val}{k}$.


We define \emph{length} of a strategy $\stg$ on a valuation $\val$,
  denoted $\stglen{\stg}{\val}$,
  as the smallest $k\in\Nseto$ such that
  $\stgknow{\stg}{\val}{k} = \form_0 \wedge \form_1 \wedge ... \wedge \form_k$ has only one model
  ($\numval_\Var{\stgknow{\stg}{\val}{k}} = 1$).
This corresponds to the point where we can uniquely
  determine the code.

Note that it always holds $\numval{\stgknow{\stg}{\val}{k}} > 0$
  because
  $\val(\form_i) = 1$ for all $i\in\Nseto$.

\TODO{Define average number of experiments.}

The \emph{worst-case number of experiments} $\lenmax{\stg}$
  of a strategy $\stg$ is the maximal length of the strategy on a valuation $\val$,
  over all models $\val$ of $\form_0$, i.e.
  \[
  \lenmax{\stg} = \max_{\val\in\Val_\Var, \;\val(\form_0) = 1} \stglen{\stg}{\val}.
  \]
We say that a strategy $\stg$ \emph{solves the game} if $\lenmax{\stg}$ is finite.
The game is \emph{solvable} if there exists a strategy that solves the game.

% \TODO{Není to jednoduchý, ale je to zajímavý?
% Given a code-breaking game $\game$, decide whether $\game$ is solvable.}

\begin{definition}[Optimal strategy]
A strategy $\stg$ is \emph{worst-case optimal} if
  $\lenmax{\stg} <= \lenmax{\stg'}$ for any strategy $\stg'$.
\end{definition}

\begin{lemma}
Let $b = \max_{\expt\in\Expt} |\outcome(\expt)|$ be the maximal number of
  possible outcomes of an experiment. Then for every strategy $\stg$,
  \[
  \lenmax{\stg} >= \lceil \log_b(\numval{\init}) \rceil.
  \]
\end{lemma}

\begin{proof}
For a fixed $\stg$ and $k = \lenmax{\stg}$,
  $\stgknow{\stg}{\val}{k}$ can \TODO{nabývat} at most
  $b^k$ values.
By pidgeon-hole principle, if $\numval{\init} > b^k$, there must be a valuation
  $v$ such that $\stgknow{\stg}{\val}{k} > 1$.
This would be a contradiction with $k = \lenmax{\stg}$ and, therefore,
  $\numval{\init} <= b^k$, which is equivalent with the statement of the lemma.
\end{proof}

\subsection{Non-adaptive strategies}
\begin{definition}[Non-adaptive strategy]
A strategy $\stg$ is \emph{non-adaptive} if it decides the next experiment
  based on the length of the solving process only, i.e.
  whenever
  $\proc_1 = e_1, \form_1, ..., e_k, \form_k$ and
  $\proc_2 = e'_1, \form'_1, ..., e'_k, \form'_k$,
  then $\stg(\proc_1) = \stg(\proc_2)$.

Non-adaptive strategies can be seen as functions $\Nseto -> \Exp$.
\end{definition}

Non-adaptive strategies corresponds to the well studied problems of
  static mastermind and
  non-adaptive strategies for the coutnerfeit coin problem.
We mention them here only to show the possibility of formulating these problems
  in our formalism but we do not study them any further.

\subsection{Memory-less strategies}

\begin{definition}[Memory-less strategy]
A strategy $\stg$ is \emph{memory-less} if it decides the next experiment
  based on the accumulated knowledge only, i.e.
  whenever
  $\proc_1 = e_1, \form_1, ..., e_k, \form_k$ and
  $\proc_2 = e'_1, \form'_1, ..., e'_l, \form'_l$
  are two solving processes such that
  $ \form_1 \wedge ... \wedge \form_k \equiv \form'_1 \wedge ... \wedge \form'_l$,
  then
  $\stg(\proc_1) = \stg(\proc_2)$.

Memory-less strategies can be considered as functions $\Form_\Var -> \Exp$.
\end{definition}

\begin{lemma}
Let $\stg$ be a memory-less strategy and $\val$ a model of $\init$.
If there exists $k\in\Nset$ such that
  $\numval{\stgknow{\stg}{\val}{k}} = \numval{\stgknow{\stg}{\val}{k+1}}$,
 then
  $\numval{\stgknow{\stg}{\val}{k}} = \numval{\stgknow{\stg}{\val}{k+l}}$
 for any $l\in\Nset$.
\end{lemma}

\begin{proof}
For the sake of simplicity, let $\know^k = \stgknow{\stg}{\val}{k}$.
There is a formula $\form\in\outcome(\know^k)$,
  such that $\know^{k+1} \equiv \know^{k} \wedge \form$.
Therefore, if $\know^{k+1}$ is satisfied by valuation $\val$, so must be $\know^{k}$.
Since $\numval{\know^{k}} = \numval{\know^{k+1}}$, the sets of
  valuations satisfying $\know^{k}$ and $\know^{k+1}$ are exactly the same
  and the formulas are thus equivalent.
This implies $\stg(\know^{k}) = \stg(\know^{k+1})$ and $\know^{k+2} \equiv \know^{k+1}\wedge \form \equiv \know^{k+1}$.

By induction,
  $\stg(\know^{k+l}) = \stg(\know^{k})$ and
  $\know^{k+l} \equiv \know^{k}$
  for any $l\in\Nset$.\qed
\end{proof}

\begin{definition}[Greedy strategy]
Let $f: \Form_\Var -> \Zset$.
A memory-less strategy $\stg$ is \emph{$f$-greedy} if
  for every $\form\in\Form_X$ and $\exp'\in\Exp$,
\[
\max_{\formx \in \outcome(\stg(\form)) \atop \SAT{\form\wedge\formx}} f(\form\wedge\formx) <=
\max_{\formx \in \outcome(e) \atop \SAT{\form\wedge\formx}} f(\form\wedge\formx).
\]
In words, a greedy strategy minimizes
  the value of $f$ on the formula in the next step.
We say $\stg$ is \emph{greedy} if it is $\numval_\Var{}$-greedy.
\end{definition}

\begin{lemma}
Let $b = \max_{\expt\in\Expt} |\outcome(\expt)|$ be the maximal number of
  possible outcomes of an experiment.
If for any \TODO{reachable} $\form\in\Form_\Var$,
\[
  \exists\exp . \max_{\formx\in\outcome(\exp)} \numval{(\form\wedge\formx)} =
  \left\lceil \frac{\numval{\form}}{b} \right\rceil,
\]
then a greedy strategy $\stg$ is optimal and
\[
  \lenmax{\stg} = \lceil \log_b(\numval{\init}) \rceil.
\]
\end{lemma}

\begin{example}
Greedy strategies are optimal in the fake-coin game $\mathcal{F}_n$.
\TODO{...}
\end{example}

% \begin{problem}
% Given a code-breaking game $\game$,
%   decide whether all greedy strategies are optimal.
% Hypothesis: It is the case for Fake-coin problem (?).
%   It is not the case for Mastermind[ref].
% \end{problem}

\input{game-symmetries}
\input{symmetry-breaking}
