\chapter{Code-breaking Games}

%-------------------------------------------------------------------------------
% DEF: CODE BREAKING GAME
%\section{Formal definition}

\TODO{Motivace: Ve hře chci najít přiřazení proměnných. Hru tedy reprezentuju jako
mnozinu promennych, a jakousi mnozinu experimentu. Po provedeni experimentu
dostanu formuli v danych promennych, o ktere vim, ze je splnena v hledane valuaci.
Tato formule reprezentuje castecnou informaci, kterou jsem experimentem ziskal.
Kazdy experiment muze dopadnout vice zpusoby, pro kazdy mam tedy mnozinu
moznych formuli, ktere mi da.}

% Intuitively, the objective of the game is to find a valuation of
%   variables $\Var$ by a series of experiments.
% Let us call it \emph{the wanted valuation}.
% The search space is reduced by formula $\init$,
%   which is always known to be satisfied by the wanted valuation.

% Experiments consist of a type, which is from the set $\Expt$ and a
%   parametrization, which is a string of variables from $\Var$.
% The experiment relation $\Exp$ specifies all permitted parameterizations
%   for each type of experiment and, therefore, $\Exp$ is the set of
%   all possible experiments as pairs.

% The outcome function gives us the possible outcomes of an experiment.
%   We require that exactly one of them must be satisfied by every valuation
%   by which $\init$ is satisfied.

\TODO{
Pro kompaktni zapis reprezentuju experiment jako dvojici (typ experimentu, parametrizace),
kde parametrizace je retezec nad danou abecedou.
Pro kazdy typ experimentu pak mam mnozinu parametrizovanych formuli.}
This whole idea is formalized below.

\begin{definition} \label{def-game}
A \emph{code-breaking game} is a septuple
  $\game = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$, where
  \begin{itemize}
  \item $\Var$ is a finite set of propositional variables,
  \item $\init \in \Form_\Var$ is a satisfiable prepositional formula,
  \item $\Expt$ is a finite set of types of experiments,
  \item $\Sigma$ is a finite alphabet,
  \item $\Exp \subseteq \Expt \times \Sigma^\star$ is an \emph{experiment} relation,
  and
  \item $F$ is a finite collection of functions of type $\Sigma -> \Var$,
  \item $\outcome: \Expt -> 2^{\PForm_{\Var,F,\Sigma}}$ is an
  \emph{outcome function} such that $\outcome(\expt)$ is finite
  for any $\expt\in\Expt$. Definition of $\PForm$ follows (Definition \ref{def-pform}).
  \end{itemize}
\end{definition}

\begin{definition} \label{def-pform}
A set of \emph{parametrized formulas} $\PForm_{\Var,F,\Sigma}$ is a set of
 all strings $\pform$ generated by the following grammar:
$$ \pform ::= x \| f(\$n) \| \pform \circ \pform \| \neg \pform,$$
where $x\in\Var$, $f\in F$, $n \in\Nset$, and $\circ\in\{\wedge, \vee, =>\}$.
By $\pform(\param)$ we denote application of a parametrization $\param\in\Sigma^\star$
on a formula $\pform$, which is defined recursively on the stucture of $\pform$ in the following way:
\begin{align}
(x)(\param) &= x, \\
(f(\$n))(\param) &= f(\param[n]),\\
(\pform_1\circ\pform_2)(\param) &= \pform_1(\param) \circ \pform_2(\param),\\
(\neg\pform)(\param) &= \neg(\pform(\param)).
\end{align}
\end{definition}

\TODO{Znak $\$$ v $f(\$n)$ je od toho, aby to nematlo, ze $n$ je argumentem funkce.}

\TODO{Poznamka o tom, ze tohle me neomezuje oproti popsane intuici. V nejhorsim muzu pro kazdy experiment udelat zvlastni typ.}

For the sake of simplicity, let us write $\outcome(\exp) = \{ \pform(\param) \| \pform\in\outcome(\expt)\}$ for any experiment
$\exp = (\expt, \param) \in \Exp$.

A code-breaking game is \emph{well-formed} if for all $(\expt, \param) \in \Exp$,
\begin{equation} \label{prop-outcome}
\forall\val\in\Val_\Var:  \val(\init) = 1 ==> \exists \textrm{ exactly one }\psi\in\outcome(\expt)\;.\; \val(\psi(\param)) = 1
\end{equation}

This guarantees that the result of every experiment is uniquely defined for any valuation.
Note that this property is not easy to check.
In sequel, we suppose a game to be well-fordmed, if not stated otherwise.

%-------------------------------------------------------------------------------
% EXAMPLE: FAKE-COIN PROBLEM

\begin{example}[Fake-coin problem] \label{form-fake-coin1}
Fake-coin problem with $n$ coins, one of which is fake, can be formalized as
a code breaking game
$\mathcal{F}_n = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$.

\begin{itemize}
\item
$\Var = \{x_1, x_2, ..., x_n, y\}$, \\
$\init = \exactly{1}\{x_1, ..., x_n\}$. \\
Intuitively, variable $x_i$ tells weather the coin $i$ is fake.
Variable $y$ tells weather it is lighter or heavier.
Formule $\init$ says that exactly one coin is fake.

\item
$\Expt = \{ w_2, w_4, ..., w_n \}$, \\
$\Sigma = \{1, 2,...,n\}$, \\
$\Exp = \bigcup_{1<=m<=n/2} \{ (w_{2m}, \param) \|
  \param \in \{1,...,n\}^{2m}, \forall x\in\Var. \#_x(\param)<=1 \}. $\\
There are $n/2$ types of experiment -- according to the number of coins we put on the weights.
The alphabet contains natural numbers up to $n$ and
possible parametrizations for $w_{2m}$ are strings of length $2m$ with no repetitions.

\item
$F = \{ f_x \}$, where $f_x(i) = x_i$ for $1 <= i <= n$, \\
$\outcome(w_m) = $ \vspace{-4mm}
\begin{align*}
  \big\{
& ((f_x(\$1) \vee ... \vee f_x(\$m)) \wedge \neg y) \vee ((f_x(\$m+1) \vee ... \vee f_x(\$2m)) \wedge y), \\
& ((f_x(\$1) \vee ... \vee f_x(\$m)) \wedge y) \vee ((f_x(\$m+1) \vee ... \vee f_x(\$2m)) \wedge \neg y), \\
& \neg (f_x(\$1) \vee ... \vee f_x(\$2m)) \big\}.
\end{align*}
There are 3 possible outcomes of every experiment.
First, the right side is heavier. This happens if the fake coin is lighter and it appears in the first half of the parametrization, or if it is heavier and it appears in the second half. Second, analogously, the left side is heavier.
Third, the weights are balanced if the fake coin do not participate in the experiment.
\end{itemize}
\end{example}
\newpage
%-------------------------------------------------------------------------------
% EXAMPLE: FAKE-COIN PROBLEM - alternative

\begin{example}[Fake-coin problem, alternative] \label{form-fake-coin2}
For demonstration purposes, here is another formalization of the same problem.
$\mathcal{F'}_n = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$.

\begin{itemize}
\item
$\Var = \{x_1, x_2, ..., x_n, y_1, y_2, ..., y_n\}$, \\
$\init = \exactly{1}\{x_1, ..., x_n, y_1, ..., y_n \}$. \\
Variable $x_i$ tells that the coin $i$ is lighter, variable $y_i$ tells that the coin $i$ is heavier.
Formule $\init$ says that exactly one coin is different.

\item
$\Expt, \Sigma, \Exp$ is defined as in Example \ref{form-fake-coin1}.

\item
$F = \{ f_x, f_y \}$, where $f_x(i) = x_i$ and $f_y(i) = y_i$ for $1 <= i <= n$, \vspace{-1.5mm}
\begin{flalign*}
\outcome(w_m) = \big\{ & (f_x(\$1) \vee ... \vee f_x(\$m)) \vee (f_y(\$m+1) \vee ... \vee f_y(\$2m)), & \\
& (f_y(\$1) \vee ... \vee f_y(\$m)) \vee (f_x(\$m+1) \vee ... \vee f_x(\$2m)), & \\
& \neg (f_x(\$1) \vee ... \vee f_x(\$2m) \vee f_y(\$1) \vee ... \vee f_y(\$2m)) \big\}. &
\end{flalign*}
\end{itemize}
\end{example}

%-------------------------------------------------------------------------------
% EXAMPLE: MASTERMIND

\begin{example}[Mastermind] \label{form-mastermind}
Mastermind puzzle with $n$ pegs and $m$ colors can be formalized as
a code breaking game
$\mathcal{M}_{n,m} = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$.

\begin{itemize}
\item
$\Var = \{x_{i,j} \| 1<=i<=n, 1<=j<=m \}$, \\
$\init = \bigwedge\left\{
  \exactly{1} \{x_{i,j} \| 1<=j<=m\} \| 1<=i<=n\right\}$. \\
Variable $x_{i,j}$ tells whether there is the color $j$ at position $i$.
Formula $\init$ says that there is exactly one color at each position.

\item
$\Expt = \{ g_{k_1,...,k_m} \| k_i \in \{1,...,n\}, \sum_ik_i = n \}$,\\
$\Sigma = C$, \\
$\Exp = \{(g_{k_1,...,k_m}, \param) \| \param\in\Sigma^{n}, \#i.(\param[i]=j)=k_j\}$.\\
The type $g_{k_1,...,k_m}$ covers all the guesses in which the number of $j$-colored pegs is $k_j$.
Therefore, two guesses for which we use the same pegs (pegs are just shuffled) are of the same type,
but if we change a peg for one with different color, it is other type of experiment.

\item
$F = \{ f_1, ..., f_n \}$, where $f_i(c) = x_{i,c}$ for $1<=i<=n$,
\vspace{-2mm}
\begin{flalign*}
\outcome(& g_{k_1,...,k_n}) =  \Big\{ &\\
 & \exactly{b}\{ f_i(\$i) \| 1<=i<=n \} \;\wedge &\\
 & \exactly{t}\bigcup
      \big\{
           \{ \atleast{l}(x_{1,j},...,x_{n,j}) \| 1 <= l <= k_j \}
           \| 1<=j<=m
      \big\} &\\
  &\hspace{2cm} \| 0<=b<=t, 0<=t<=n\Big\}.
\end{flalign*}
\TODO{Zdůvodnit proč to funguje.}
\end{itemize}
\end{example}

%-------------------------------------------------------------------------------
% EXAMPLE: MASTERMIND 2

\begin{example}[Mastermind (alternative)] \label{form-mastermind2}
$\mathcal{M'}_{n,m} = (\Var, \init, \Expt, \Sigma, \Exp, F, \outcome)$.

\begin{itemize}
\item
$\Var$ and $\init$ is defined as in Example \ref{form-mastermind}. \\

\item
$\Expt = \{ g \}$,\\
$\Sigma = C$, \\
$\Exp = \{(g, \param) \| \param\in\Sigma^{n}\}$.\\

\item
$F = \{ f_1, ..., f_n \}$, where $f_i(c) = x_{i,c}$ for $1<=i<=n$,
$\outcome(g) = \{ \textrm{Outcome}(b, w) \| 0<=b<=n, 0<=w<=n, b+w<=n \}$,
where $\textrm{Outcome}$ function is computed by the algorithm described below.
\end{itemize}

\newcommand{\BlackSymb}{\bullet}
\newcommand{\NoSymb}{\times}

Consider a fixed color combination (code) and a guess.
We assign a symbol $\BlackSymb$, $\NoSymb$ or a number to each position
  in the following way.
If the color at a position is same in the code and the guess, we assign
  $\BlackSymb$ to this position and the player gets a black peg for it.
If the color in the guess at position $i$ differs but it appears
  appears at position $j$ in the code, we assign $j$ to position $i$ and
  the player gets a white peg. Also, position $j$ must not be assigned
  $\BlackSymb$ and the number $j$ must not be assigned to any other position.
We assign $\NoSymb$ to all other positions.
For example, if the code is $1234$ and the guess is $5251$, the assignment is
 $\underline{\NoSymb\BlackSymb\NoSymb\:1}$.

We start the computation of Outcome$(b, w)$ with generation of
  all combinations of $\BlackSymb$, $\NoSymb$ and different numbers from $1$ to
  $n$,
  so that there is $b$-times $\BlackSymb$, $w$-times a number and
  no number refers to a position with $\BlackSymb$.

Next, for each combination, we generate a conjunction in the following way:
\begin{itemize}
\item For $\BlackSymb$ at position $i$, we add $f_i(\$i)$.
\item For a number $j$ at position $i$, we add $\neg f_i(\$i) \wedge f_j(\$i)$.
\item For $\NoSymb$ at position $i$, we add $\neg f_j(\$i)$ for any other position $j$ with $\NoSymb$.
\end{itemize}
The result is a disjunction of all these clauses, which effectively enumerates all the cases.

To get a better idea about the results, this is $\textrm{Outcome}(1, 1)$ for n = 4:

\medskip
\begin{scriptsize}$(
\neg f_0(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_0(\$2) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_0(\$2) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_2(\$0) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_1(\$1) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge f_3(\$3)) \vee
(\neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_3(\$1) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_2(\$2) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_1(\$1) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_1(\$3) \wedge \neg f_2(\$1) \wedge \neg f_2(\$2) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_1(\$1) \wedge \neg f_1(\$2) \wedge \neg f_1(\$3) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_0(\$0)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_3(\$0) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_0(\$3) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_0(\$3) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$1) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_1(\$1) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_1(\$0) \wedge \neg f_1(\$1) \wedge \neg f_1(\$3) \wedge \neg f_3(\$1) \wedge \neg f_3(\$3) \wedge f_2(\$2)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_3(\$0) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
(\neg f_0(\$0) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_0(\$3) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_0(\$3) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$2) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_2(\$2) \wedge \neg f_3(\$0) \wedge \neg f_3(\$3) \wedge f_1(\$1)) \vee
(\neg f_0(\$0) \wedge \neg f_0(\$3) \wedge \neg f_2(\$0) \wedge \neg f_2(\$2) \wedge \neg f_2(\$3) \wedge \neg f_3(\$2) \wedge \neg f_3(\$3) \wedge f_1(\$1)
).$
\end{scriptsize} \medskip

However complicated this may look, note that it is not much different from
 the previous model where the complexity of the formulas was hidden in the
 Exactly and AtLeast macro operators.
\end{example}

%-------------------------------------------------------------------------------
% DEF: STRATEGY
\section{Strategies}

\begin{definition}
A \emph{strategy} is a function $\stg: \Form_\Var -> \Exp$,
determining the next experiment for given accumulated knowledge,
such that
\[
\form_0 \equiv \form_1 ==> \stg(\form_0) = \stg(\form_1).
\]
\end{definition}

A strategy $\stg$ together with a valuation $\val$ (satisfying $\form_0$) induce
  a \emph{solving process}, which is an infinite sequence
\[
\procstg{\stg}{\val} = \form_0 \arrow{\exp_1} \form_1 \arrow{\exp_2}
  \form_2 \arrow{\exp_3} ...,
\]
where $\exp_i = \stg(\form_0 \wedge \form_1 \wedge ... \wedge \form_{i-1})$ and
$\form_i \in \outcome(\exp_i)$ and $\val(\form_i) = 1$,
for all $i\in\Nset$. Notice that due to the condition \ref{prop-outcome},
there is always exactly one such $\pform_i$.

For the sake of simplicity, let us write $\aform{k}$
instead of $\form_0 \wedge \form_1 \wedge ... \wedge \form_k$.

We define \emph{length} of the solving process,
  denoted $|\procstg{\stg}{\val}|$
  (despite the infinite length of the sequence),
  as the smallest $k\in\Nseto$ such that
  $\numval_\Var(\aform{k}) = 1$.
This corresponds to the point where we can uniquely
  determine the valuation used in the process
  (i.e. we can determine the secret code).
Note that it always holds $\numval(\aform{k}) > 0$ because
  $\val(\form_i) = 1$ for all $i\in\Nseto$.

The following lemma is a straightforward consequence
  of the memory-less nature of the games. It says that once a strategy
  gives us an experiment that yields no new information, we will never get
  any new information (using the strategy).

\begin{lemma}
If $\numval(\aform{k}) = \numval(\aform{k+1})$ for some $k\in\Nset$,
then $\numval(\aform{k}) = \numval(\aform{k+l})$ for any $l\in\Nset$.
\end{lemma}

\begin{proof}
If $\aform{k+1} = \aform{k} \wedge \form_{k+1}$
is satisfied by valuation $\val$, so must be $\aform{k}$.
Since $\numval(\aform{k}) = \numval(\aform{k+1})$, the sets of
valuations satisfying $\aform{k}$ and $\aform{k+1}$ must be exactly the same
and the formulas are thus equivalent. This implies
$\stg(\aform{k}) = \stg(\aform{k+1})$ and thus also $\form_{k+2} = \form_{k+1}$.
By induction, $\form_{k+l} = \form_{k+1}$ and $\aform{k+l} \equiv \aform{k}$
 for any $l\in\Nset$.\qed
\end{proof}

The \emph{worst-case number of experiments} $\lenmax{\stg}$
  of a strategy $\stg$ is the maximal length of the solving process
  $\procstg{\stg}{\val}$ over all valuations $\val$ by which $\form_0$ is satisfied,
  i.e.
  $\lenmax{\stg} = \max_{\val\in\Val_\Var, \val(\form_0) = 1} |\procstg{\stg}{\val}|$.
We say that a strategy $\stg$ \emph{solves the game} if $\lenmax{\stg}$ is finite.
The game is \emph{solvable} if there exists a strategy that solves the game.

\TODO{Není to jednoduchý, ale je to zajímavý?
Given a code-breaking game $\game$, decide whether $\game$ is solvable.}

\begin{definition}
A strategy $\stg$ is \emph{optimal} if
  $\lenmax{\stg} <= \lenmax{\stg'}$ for any strategy $\stg'$.
\end{definition}

\begin{definition}
Let $f: \Form_\Var -> \Zset$.
A strategy $\stg$ is \emph{$f$-greedy} if
  for every $\form\in\Form_X$ and $\exp'\in\Exp$,
\[
\max_{\formu \in \outcome(\stg(\form)), \SAT{\form\wedge\formu}} f(\form\wedge\formu) <=
\max_{\formu \in \outcome(e), \SAT{\form\wedge\formu}} f(\form\wedge\formu).
\]
In words, a greedy strategy minimizes
  the value of $f$ on the formula in the next step.

We say $\stg$ is \emph{greedy} if it is $\numval_\Var$-greedy.
\end{definition}


\begin{problem}
Given a code-breaking game $\game$,
  decide whether all greedy strategies are optimal.
Hypothesis: It is the case for Fake-coin problem (?).
  It is not the case for Mastermind[ref].
\end{problem}

%-------------------------------------------------------------------------------

\begin{definition}
An experiment $\exp_1$ is in relation $\sim_\form$ with an experiment $\exp_2$ if
 and only if there exists a permutation $\perm\in\Perm_\Var$ such that
 $ \{ \form\wedge\formu \| \formu\in\outcome(\exp_1) \} \equiv
   \{ (\form\wedge\formu)^\perm \| \formu\in\outcome(\exp_2) \} $.
\end{definition}

Meaning?