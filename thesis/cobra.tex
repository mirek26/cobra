\chapter{COBRA tool}
\label{ch:cobra}
Development of a general tool for
  code-breaking games analysis is the main part of this work.
We named the tool COBRA, the \textbf{co}de-\textbf{br}eaking game \textbf{a}nalyzer.
Input of the tool is a game specification in a special language, which
  we describe first.
Basic usage is explained afterwards with
  a description of various tasks that the tool can perform with a loaded game.
Notes on dependencies and requirements on external tools,
  on extensibility of COBRA and
  some more implementation details
  are described in later sections.

Source codes of the tool, together with a detailed documentation
  and specifications of the games described in \autoref{ch:games}
  can be found in the electronic attachment of the thesis.
A git repository on GitHub\footnote{\url{http://www.github.com}}
  was used during the development,
  so another way of obtaining the source codes is by cloning
  the repository at \url{https://github.com/myreg/cobra}.
This website also serves as a homepage of the project, and contains
  all related documents.

COBRA is available under \emph{BSD 3-Clause License}\footnote{\url{http://opensource.org/licenses/BSD-3-Clause}},
  text of which is a part of source codes.
\TODO{Jak je to s licenci Picosatu a tak? Zminit tady.}

\section{Input language} \label{sec:lng}

First we describe the low-level language that is the input format of COBRA.
Next, the language is equipped with a preprocessor that allows
  parametrized generation of the low-lever format.

\subsection{Low-level language}

The low-level language is directly based on \autoref{def:game}, the formal definition of
  code-breaking games.
It is case-sensitive and whitespace is not significant at any position.

\newcommand{\symb}[1]{\textcolor{DarkBlue}{$<$#1$>$}}
%\newcommand{\txt}[1]{\;\textcolor{DarkRed}{\textsc{#1}}\;}
\newcommand{\txt}[1]{\;\textsc{#1}\;}
\newcommand{\term}[1]{\;\textrm{#1}\;}

From a lexical point of view, there are three atoms.
Identifier (\symb{ident}), is a string starting with a letter or underscore,
  which may contain letters, digits and underscores.
Integer (\symb{int}) is a sequence of digits.
String (\symb{string}) is sequence of arbitrary characters enclosed in quotes.
Further, list of X (\symb{x-list}) is a comma-separated list of atoms of type X,
  generated by grammar \symb{x-list} $::=$ \symb{x} $\|$ \symb{x-list}~,~\symb{x}.

The input file is parsed by lines, each of which must have one of the forms
  listed in the following table.

\begin{tabular}{|p{.4\textwidth}|p{.54\textwidth}|}
 \hline
\textsc{Variable} \symb{ident} &
    Declares a variable with a given identifier. \\
\textsc{Variables} \symb{ident-list} &
    Declares variables with given identifiers. \\
\textsc{Restriction} \symb{formula} &
    Defines the initial restriction $\init$. \\
\textsc{Alphabet} \symb{string-list} &
    Defines the parametrization alphabet $\Sigma$. \\
\textsc{Mapping} \symb{ident} \symb{ident-list} &
    Defines a mapping with a given identifier.
    The seconds argument is a list of variable identifiers defining
      the values of the mapping for all elements of the alphabet.    \\
\textsc{Experiment} \symb{string} \symb{int} &
    Opens a section defining a new experiment named by the first argument
      and having the number of parameter given by the second argument.
    The section closes automatically with a definition of a new experiment. \\
\textsc{Params-distinct} \symb{int-list} &
    Defines a restriction on the parameters of the experiment,
      requiring that parameters at specified positions are different.
    This is the only type of allowed restriction. \\
   %\\ \| \txt{Params-sorted} \symb{int-list}
\textsc{Outcome} \symb{string} \symb{formula} &
    Defines an outcome of the experiment named by the first argument. \\ \hline
\end{tabular} \medskip

We specify what ``formula'' is by the following grammar:

\medskip
\begin{tabular}{rl}
 \symb{formula} ::=\;
    & \symb{ident$_1$} $\;\;\|\;\;$ ( \symb{formula} )
       $\;\;\|\;\;$ ! \symb{formula} \\
 $\|$ & \symb{formula} $\circ$ \symb{formula}
       $\;\;\|\;\;$ \texttt{X}-\symb{int$_1$} ( \symb{formula-list} ), \\
 $\|$ & \symb{ident$_2$} (\$ \symb{int$_2$} ),
\end{tabular}
\medskip

where \symb{ident$_1$} is an identifier of a variable
and $\circ\in\{$and, $\&$, or, $|\:$, --$>$, $<$--, $<$--$>\}$
is a standard logical operator with its usual meaning.

\texttt{X} is one of $\atleast$, $\atmost$, $\exactly$
  and we call it a \emph{numerical operator}.
Let $\form := \mathtt{X}$-$k(\form_1, ..., \form_n)$ be a formula,
  $v$ a valuation of the variables and let $s$ be the number
  of satisfied formulas among $\form_1, ...\form_n$ by valuation $v$.
Then the formula $\form$ is satisfied by $v$ if and only
  if $s>=k$, $s<=k$ and $s=k$,
  for $X$ being $\atleast$, $\atmost$ and $\exactly$, respectively.
These operators are non-standard and could be cut out,
  however, they are quite common and useful in specification of code-breaking games
  and their na\"ive expansion to standard operators causes exponential
  expansion of the formula (with respect to $k$).
Hence we support these operators in the language and we handle
  them specifically during the transformation to CNF,
  avoiding the exponential expansion by introduction of new variables.
The conversion is described in detail in \autoref{s:cobra-sat}.

Finally, the last rule of the grammar allows for formula parametrization.
This can appear only in formulas defining an outcome of an experiment.
The first part, \symb{ident$_2$}, must be an identifier of a defined mapping,
  and \symb{int$_2$} must be in the range from 1 to the number of parameters
  of the currently defined experiment.

\begin{example}
\TODO{Running example.}
\begin{lstlisting}
VARIABLES y, x1, x2, x3, x4
RESTRICTION Exactly-1(x1, x2, x3, x4)
ALPHABET '1', '2', '3', '4'
MAPPING X x1, x2, x3, x4

EXPERIMENT 'weighing2x2' 4
  PARAMS_DISTINCT 1, 2, 3, 4
  OUTCOME 'lighter' ((X$1 | X$2) & !y) | ((X$3 | X$4) & y)
  OUTCOME 'heavier' ((X$1 | X$2) & y) | ((X$3 | X$4) & !y)
  OUTCOME 'same' !(X$1 | X$2 | X$3 | X$4)
\end{lstlisting}
\end{example}

To parse this language, we use a standard combination of
\emph{GNU Flex}\footnote{\url{http://flex.sourceforge.net/}} for lexical analysis and
\emph{GNU Bison}\footnote{\url{http://www.gnu.org/software/bison/}} for parser generation.
The exact LALR grammar used can be found in $\texttt{cobra.ypp}$ file
  in the source codes.

\subsection{Python preprocessing}

Although the low-level language is sufficient for our purposes,
  it is not very user-friendly and
  simple changes in a game may require extensive changes in the input file.
For exapmle, if you want to change the number of coins in the Counterfeit Coin problem,
  it would be nice to change only one number in the input
  but now you have to change many lines and create or delete some experiment sections.
The situation is even worse in Mastermind, in which the outcome formulas are
  generated by the algorithm described in \ref{ex:form-mastermind}.
We would need to write a script or a computer program to generate the input file.

This is the point where preprocessor comes into the picture.
As the demands may significantly differ for different games,
  we decided not to create our own preprocessing engine
  and use Python\footnote{\url{https://www.python.org}},
  a popular and intuitive scripting language, instead.

The input can now be an arbitrary Python file with calls to extra functions
\textsc{Variable}, \textsc{Variables}, \textsc{Restriction}, \textsc{Alphabet},
\textsc{Mapping}, \textsc{Experiment}, \textsc{Params-distinct} and \textsc{Outcome},
which map directly to the constructs in the low-level language.

The generation of the low-level input is done by execution of the Python file
  with those special function ingested.
All the functions do is printing the corresponding low-level language constructs
  to the output file.
Types of their parameters are listed below.

\begin{center}
\begin{tabular}{lcc}
 \multicolumn{1}{c}{\textbf{Function}} & \textbf{Type of x} & \textbf{Type of y} \\\hline
\textsc{Variable}(x) & string & - \\
\textsc{Variables}(x) & list of strings & -\\
\textsc{Restriction}(x) & formula (as a string)& -\\
\textsc{Alphabet}(x) & list of strings & -\\
\textsc{Mapping}(x, y) & string & list of strings\\
\textsc{Experiment}(x, y) & string & integer \\
\textsc{Params-distinct}(x) & list of integers & -\\
\textsc{Outcome}(x, y) & string & formula (as a string)
\end{tabular}
\end{center}

\begin{example}
An example specification of the counterfeit coin problem,
based on \autoref{ex:cc1}, follows.
\begin{lstlisting}[language=Python]
N = 12
x_vars = ["x" + str(i) for i in range(N)]
VARIABLES(["y"] + x_vars)
RESTRICTION("Exactly-1(%s)" % ",".join(x_vars))
ALPHABET([str(i) for i in range(N)])
MAPPING("X", x_vars)

# Helper function for disjunction of parameters
# For example, params(2,4) = "X$2 | X$3 | X$4"
params = lambda n0, n1: "|".join("X$" + str(i)
                                 for i in range(n0, n1 + 1))

for m in range(1, N//2 + 1):
  EXPERIMENT("weighing" + str(m), 2*m)
  PARAMS_DISTINCT(range(1, 2*m + 1))
  OUTCOME("lighter", "((%s) & !y) | ((%s) & y)" %
                     (params(1, m), params(m+1, 2*m)))
  OUTCOME("heavier", "((%s) & y) | ((%s) & !y)" %
                     (params(1, m), params(m+1, 2*m)))
  OUTCOME("same", "!(%s)" % params(1, 2*m))
\end{lstlisting}
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation and basic usage}

COBRA is written in C++ and uses some features of the modern C++11 standard
  so you need a modern C++ compiler to build the tool.
We have tested and can recommend \texttt{gcc} version $4.8$ or higher,
  or \texttt{clang} version $3.2$ or higher.
To compile the tool, run
  \texttt{make}
  in the program folder.
It automatically compiles external tools and builds the necessary libraries.
If everything finishes successfully,
  the binary executable \texttt{cobra-backend} is created
  and ready for being used.

The basic syntax to launch the tool is the following.

\medskip
\centerline{\texttt{./cobra [-m <mode>] [-b <backend>] [other options] <input file>}}
\medskip


Mode of operation, specified by \texttt{-m} switch,
  specifies what the tool will do with the game.
The four possible modes are described in \autoref{s:cobra-modes},
  together with the description
  of other options that depend on the mode.
Backend, specified by \texttt{-b} switch, specifies which backend should be
  used for SAT solving and model counting.
In most cases, you should be fine with the default backend and can ignore this option.
Details can be found in \autoref{s:cobra-sat}.

The main executable, \texttt{cobra}, is a Python script that preprocesses
  the input file and writes the low-level game specification to \texttt{.cobra.in}.
Then it executes \texttt{cobra-backend} and passes on all the options given
  by the user.
Thus, if you want to run COBRA on a low-level input format, you can run
  \texttt{cobra-backend} directly with the same syntax..

Before \texttt{cobra-backend} finishes, it always outputs a \emph{time overview},
  with information on how much time was spend on which operations and
  how many calls to the SAT solver and to the symmetry breaker has been made.

\begin{figure}[h]
\begin{lstlisting}
===== TIME OVERVIEW =====
Total time: 74.68s
Bliss (calls/time): 1984 / 0.10s
SAT solvers         sat             fixed           models
* PicoSolver      59 / 0.09s     197  / 0.26s     5635 / 73.23s
\end{lstlisting}
\caption{An example of the time overview after a time demanding task.}
\label{fig:timeoverview}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modes of operation}\label{s:cobra-modes}

\subsection{Overview mode [o, overview] (default)}

\centerline{\texttt{./cobra -m overview <input file> }}
\medskip

Overview mode serves as a basic check that your input file is
  syntactically correct and that the game you specified is sensible.
In this mode, the tool prints basic information about the loaded game, such as
  number of variables, number of experiments, size of the search space,
  size of the preprocessed input file,
  trivial bounds on the worst-case and expected-case number of experiments, etc.

It also performs a \emph{well-formed} check, i.e. verifies that the
  specified game is well-formed according to \autoref{def:wellformed}.

Verification that an experiment with outcomes $\formx_1,...\formx_k$ is well-formed
  can be done by verifying that $\init->\exactlyk{1}(\formx_1, ..., \formx_k)$
  is a tautology.
We negate the formula, pass it to a SAT solver, ask for satisfiability and expect a negative result.

Verification that the game is well-formed is done by
  generating possible non-equivalent experiments for the first round
  and verifying that all of them are well-formed.
This is enough thanks to \autoref{lma:exp-wellformed}
\TODO{Lemma: pokud jsou experimenty ekviv a jeden je well-formed, je i druhy well-formed.}
If a problem is found, the tool outputs an assignment and an experiment
  for which no outcome, or more that one outcome, is satisfied.

\begin{figure}
\begin{lstlisting}[xleftmargin=.2\textwidth]
Well-formed check... failed!
EXPERIMENT: weighing1 1 2
PROBLEMATIC ASSIGNMENT:
  TRUE: y x3
  FALSE: x1 x2 x4 x5 x6 x7 x8 x9 x10 x11 x12
\end{lstlisting}
\caption{An example of a failed well-formed check in the\\ counterfeit coin problem
 with missing ``='' outcome.}
\end{figure}

\subsection{Simulation mode [s, simulation]}

\centerline{\texttt{./cobra -m simulation -e <strategy> -o <strategy> <input file> }}

In the simulation mode, you specify a strategy for
  the codebreaker (which chooses an experiment) and for the codemaker
   (which chooses an outcome).
This can be done using \texttt{-e} or \texttt{--codebreaker} switch, and
\texttt{-o} or \texttt{--codemaker} switch, respectively.

We do not consider the codemaker a player who just chooses the secret code
and evaluates experiment but a player who chooses the outcomes
of experiments as they come according to his will.
The only condition is that the outcomes are consistent.

Implemented strategies for both codebreaker and codemaker
  are described in the next section and mostly correspond to strategies
  that can be found in the literature on Mastermind.
Apart from these, the tool supports two extra options for both players,
  \textbf{interactive} and \textbf{random},
  which are not strategies in the sense of \autoref{def:strategy}.

If ``interactive'' is specified as the codebreaker's strategy,
  the tool prints a list of all non-equivalent experiments in each round
  (together with the number of possible outcomes, number of fixed variables
  and number of remaining possibilities) and the user is asked
  to choose the experiment that will be performed.
This effectively allows the user to play the game against a codemaker's strategy.
Similarly, if ``interactive'' is the codemaker's strategy, possible outcomes
  are printed after each experiment and the user is asked to choose one.
Unsatisfiable outcomes are printed as well but are marked accordingly
  and the user cannot select them.

In the random mode, an experiment, or an outcome of an experiment, is
  chosen by random from the list.

The default values for both players are interactive,
  so if you run the simulation mode without any strategy specification,
  you will be first asked to select an experiment and then to select its outcome.

\subsection{Strategy analysis mode [a, analysis]}

\centerline{\texttt{./cobra -m analysis -e <strategy> <input file> }}

This makes the tool compute worst-case number of experiments and
average-case number of experiments for a given codebreaker's strategy.

\TODO{pseudocode?}

\subsection{Optimal strategy mode [o, optimal]}
\TODO{...}


\section{Strategies}

\subsection{Codebreaker's strategy}

We support the following one-step look-ahead strategies for the codebreaker.
Let $N$ denote the number of possible codes in the current state,
  and for a fixed experiment, let $n_i$ denote the number of possible codes
  for which the experiment results in outcome $i$.

\begin{description}
\item[Min-num.] \texttt{-e minnum} \\
  
\item[Min-exp.]  \texttt{-e minexp} \\
\item[Entropy.] \texttt{-e entropy} \\
\item[Most-parts.] \texttt{-e parts} \\
  
\item[Fixed.] \texttt{-e fixed} \\
  Maximize the number of fixed variables
  in the next step.
  This is specific to propositional logic representation of a code-breaking game.
  Further, it depends on the exact formalization.
  For example, \autoref{ex:cc1}
  shows two different formalizations of the same problem but
  the choice of the experiment by the \emph{fixed} strategy is
  different in the very first step.
% TODO: SAt resolutions, ... ? (jine vlastni)
\end{description}

\subsection{Codemaker's strategy}

The codemaker has the following strategy options.
Note that none of them is guaranteed to maximize the
  number of experiments of any codebreaker's strategy.

\begin{description}
\item[Max-num.] \texttt{-o maxnum} \\
  Select an outcome with largest $n_i$. This
  corresponds to the \emph{min-num} strategy for codebreaker.
\item[Fixed.] \texttt{-o fixed} \\
  Minimizes the number of fixed variables in the next step.
\end{description}

\subsection{Extensibility}

If you want to analyze a new heuristics to selects experiments,
  all you need to do is to implement a new function
  in \texttt{strategy.h/strategy.cpp} file and add a corresponding entry
  to the \texttt{...} table in \texttt{strategy.h}.
A strategy function takes a list of sensible experiments as an argument
  and it returns the index of the selected one.

If your strategy only \emph{maximizes} or \emph{minimizes}
  some metrics on the experiments,
  you can use a provided template with a corresponding lambda function.
We demonstrate this possibility with a code snippet of
  the exact implementation of the \emph{Min-exp} strategy below.
For exact details, see the documentation in the file.

\begin{lstlisting}[language=C++]
uint breaker::exp_num(vec<Option>& options) {
  return minimize([](Option& o){
    auto models = o.GetNumOfModels();
    int sumsq = 0;
    for (uint i = 0; i < o.type().outcomes().size(); i++) {
      sumsq += models[i] * models[i];
    }
    return (double)sumsq / o.GetTotalNumOfModels();
  }, options);
}
\end{lstlisting}

