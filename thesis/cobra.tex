\chapter{COBRA tool}
\label{ch:cobra}
Development of a general tool for
  code-breaking games analysis is the main part of this work.
We named the tool COBRA, the \textbf{co}de-\textbf{br}eaking game \textbf{a}nalyzer.
Input of the tool is a game specification in a special language, which
  we describe first.
Basic usage is explained afterwards with
  a description of various tasks that the tool can perform with a loaded game.
Notes on dependencies and requirements on external tools,
  on extensibility of COBRA and
  some more implementation details
  are described in later sections.

Source codes of the tool, together with a detailed documentation
  and specifications of the games described in \autoref{ch:games}
  can be found in the electronic attachment of the thesis.
A git repository on GitHub\footnote{\url{http://www.github.com}}
  was used during the development,
  so another way of obtaining the source codes is by cloning
  the repository at \url{https://github.com/myreg/cobra}.
This website also serves as a homepage of the project, and contains
  all related documents.

COBRA is available under \emph{BSD 3-Clause License}\footnote{\url{http://opensource.org/licenses/BSD-3-Clause}},
  text of which is a part of source codes.
The tool is dependent on external tools, namely Picosat, Minisat and Bliss.
Picosat and Minisat are available under \emph{MIT License};
Bliss is available under \emph{GNU GPL v3}.

\section{Input language} \label{sec:lng}

First we describe the low-level language that is the input format of COBRA.
Next, the language is equipped with a preprocessor that allows
  parametrized generation of the low-lever format.

\subsection{Low-level language}

The low-level language is directly based on \autoref{def:game}, the formal definition of
  code-breaking games.
It is case-sensitive and whitespace is not significant at any position.

%\newcommand{\txt}[1]{\;\textcolor{DarkRed}{\textsc{#1}}\;}
\newcommand{\txt}[1]{\;\textsc{#1}\;}
\newcommand{\term}[1]{\;\textrm{#1}\;}

From a lexical point of view, there are three atoms.
Identifier (\symb{ident}), is a string starting with a letter or underscore,
  which may contain letters, digits and underscores.
Integer (\symb{int}) is a sequence of digits.
String (\symb{string}) is sequence of arbitrary characters enclosed in quotes.
Further, list of X (\symb{x-list}) is a comma-separated list of atoms of type X,
  generated by grammar \symb{x-list} $::=$ \symb{x} $\|$ \symb{x-list}~,~\symb{x}.

The input file is parsed by lines, each of which must have one of the forms
  listed in the following table.

\begin{tabular}{|p{.4\textwidth}|p{.54\textwidth}|}
 \hline
\textsc{Variable} \symb{ident} &
    Declares a variable with a given identifier. \\
\textsc{Variables} \symb{ident-list} &
    Declares variables with given identifiers. \\
\textsc{Constraint} \symb{formula} &
    Defines the initial constraint $\init$. \\
\textsc{Alphabet} \symb{string-list} &
    Defines the parametrization alphabet $\Sigma$. \\
\textsc{Mapping} \symb{ident} \symb{ident-list} &
    Defines a mapping with a given identifier.
    The seconds argument is a list of variable identifiers defining
      the values of the mapping for all elements of the alphabet.    \\
\textsc{Experiment} \symb{string} \symb{int} &
    Opens a section defining a new experiment named by the first argument
      and having the number of parameter given by the second argument.
    The section closes automatically with a definition of a new experiment. \\
\textsc{Params-distinct} \symb{int-list} &
    Defines a restriction on the parameters of the experiment,
      requiring that parameters at specified positions are different.
    This is the only type of allowed restriction. \\
   %\\ \| \txt{Params-sorted} \symb{int-list}
\textsc{Outcome} \symb{string} \symb{formula} &
    Defines an outcome of the experiment named by the first argument. \\ \hline
\end{tabular} \medskip

We specify what ``formula'' is by the following grammar:

\medskip
\begin{tabular}{rl}
 \symb{formula} ::=\;
    & \symb{ident$_1$} $\;\;\|\;\;$ ( \symb{formula} )
       $\;\;\|\;\;$ ! \symb{formula} \\
 $\|$ & \symb{formula} $\circ$ \symb{formula}
       $\;\;\|\;\;$ \texttt{X}-\symb{int$_1$} ( \symb{formula-list} ), \\
 $\|$ & \symb{ident$_2$} (\$ \symb{int$_2$} ),
\end{tabular}
\medskip

where \symb{ident$_1$} is an identifier of a variable
and $\circ\in\{$and, $\&$, or, $|\:$, --$>$, $<$--, $<$--$>\}$
is a standard logical operator with its usual meaning.

\texttt{X} is one of $\atleast$, $\atmost$, $\exactly$
  and we call it a \emph{numerical operator}.
Let $\form := \mathtt{X}$-$k(\form_1, ..., \form_n)$ be a formula,
  $v$ a valuation of the variables and let $s$ be the number
  of satisfied formulas among $\form_1, ...\form_n$ by valuation $v$.
Then the formula $\form$ is satisfied by $v$ if and only
  if $s>=k$, $s<=k$ and $s=k$,
  for $X$ being $\atleast$, $\atmost$ and $\exactly$, respectively.
These operators are non-standard and could be cut out,
  however, they are quite common and useful in specification of code-breaking games
  and their naive expansion to standard operators causes exponential
  expansion of the formula (with respect to $k$).
Hence we support these operators in the language and we handle
  them specifically during the transformation to CNF,
  avoiding the exponential expansion by introduction of new variables.
The conversion is described in detail in \autoref{s:cobra-sat}.

Finally, the last rule of the grammar allows for formula parametrization.
This can appear only in formulas defining an outcome of an experiment.
The first part, \symb{ident$_2$}, must be an identifier of a defined mapping,
  and \symb{int$_2$} must be in the range from 1 to the number of parameters
  of the currently defined experiment.

\begin{example}
Recall the running example introduced in \autoref{ex:run1}.
The counterfeit-coin problem with four coins
 can be specified in the low-level language as follows.
\begin{lstlisting}
VARIABLES y, x1, x2, x3, x4
CONSTRAINT Exactly-1(x1, x2, x3, x4)
ALPHABET '1', '2', '3', '4'
MAPPING X x1, x2, x3, x4

EXPERIMENT 'weighing2x2' 4
  PARAMS_DISTINCT 1, 2, 3, 4
  OUTCOME 'lighter' ((X$1 | X$2) & !y) | ((X$3 | X$4) & y)
  OUTCOME 'heavier' ((X$1 | X$2) & y) | ((X$3 | X$4) & !y)
  OUTCOME 'same' !(X$1 | X$2 | X$3 | X$4)
\end{lstlisting}\eqed
\end{example}

To parse this language, we use a standard combination of
\emph{GNU Flex}\footnote{\url{http://flex.sourceforge.net/}} for lexical analysis and
\emph{GNU Bison}\footnote{\url{http://www.gnu.org/software/bison/}} for parser generation.
The exact LALR grammar used can be found in $\texttt{cobra.ypp}$ file
  in the source codes.

\subsection{Python preprocessing}

Although the low-level language is sufficient for our purposes,
  it is not very user-friendly and
  simple changes in a game may require extensive changes in the input file.
For example, if you want to change the number of coins in the Counterfeit Coin problem,
  it would be nice to change only one number in the input
  but now you have to change many lines and create or delete some experiment sections.
The situation is even worse in Mastermind, in which the outcome formulas are
  generated by the algorithm described in \ref{ex:form-mastermind}.
We would need to write a script or a computer program to generate the input file.

This is the point where preprocessor comes into the picture.
As the demands may significantly differ for different games,
  we decided not to create our own preprocessing engine
  and use Python\footnote{\url{https://www.python.org}},
  a popular and intuitive scripting language, instead.

The input can now be an arbitrary Python file with calls to extra functions
\textsc{Variable}, \textsc{Variables}, \textsc{Constraint}, \textsc{Alphabet},
\textsc{Mapping}, \textsc{Experiment}, \textsc{Params-distinct} and \textsc{Outcome},
which map directly to the constructs in the low-level language.

The generation of the low-level input is done by execution of the Python file
  with those special function ingested.
All the functions do is printing the corresponding low-level language constructs
  to the output file.
Types of their parameters are listed below.

\begin{center}
\begin{tabular}{lcc}
 \multicolumn{1}{c}{\textbf{Function}} & \textbf{Type of x} & \textbf{Type of y} \\\hline
\textsc{Variable}(x) & string & - \\
\textsc{Variables}(x) & list of strings & -\\
\textsc{Constraint}(x) & formula (as a string)& -\\
\textsc{Alphabet}(x) & list of strings & -\\
\textsc{Mapping}(x, y) & string & list of strings\\
\textsc{Experiment}(x, y) & string & integer \\
\textsc{Params-distinct}(x) & list of integers & -\\
\textsc{Outcome}(x, y) & string & formula (as a string)
\end{tabular}
\end{center}

\begin{example}
An example specification of the counterfeit coin problem,
based on \autoref{ex:cc1}, follows.
\begin{lstlisting}[language=Python]
N = 12
x_vars = ["x" + str(i) for i in range(N)]
VARIABLES(["y"] + x_vars)
CONSTRAINT("Exactly-1(%s)" % ",".join(x_vars))
ALPHABET([str(i) for i in range(N)])
MAPPING("X", x_vars)

# Helper function for disjunction of parameters
# For example, params(2,4) = "X$2 | X$3 | X$4"
params = lambda n0, n1: "|".join("X$" + str(i)
                                 for i in range(n0, n1 + 1))

for m in range(1, N//2 + 1):
  EXPERIMENT("weighing" + str(m), 2*m)
  PARAMS_DISTINCT(range(1, 2*m + 1))
  OUTCOME("lighter", "((%s) & !y) | ((%s) & y)" %
                     (params(1, m), params(m+1, 2*m)))
  OUTCOME("heavier", "((%s) & y) | ((%s) & !y)" %
                     (params(1, m), params(m+1, 2*m)))
  OUTCOME("same", "!(%s)" % params(1, 2*m))
\end{lstlisting}
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation and basic usage}

To compile COBRA, run \texttt{make} in the program folder.
This automatically compiles external tools and builds the necessary libraries.
If everything finishes successfully,
  the binary executable \texttt{cobra-backend} is created
  and ready for being used.
In case of a problem during the compilation, please refer to the \emph{Requirements}
paragraph of \autoref{sec:impl}.

The basic syntax to launch the tool is the following.

\medskip
\centerline{\texttt{./cobra [-m <mode>] [-b <backend>] [other options] <input file>}}
\medskip

Mode of operation, specified by \texttt{-m} switch,
  specifies what the tool will do with the game.
The four possible modes are described in \autoref{s:cobra-modes},
  together with the description
  of other options that depend on the mode.
Backend, specified by \texttt{-b} switch, specifies which backend should be
  used for SAT solving and model counting.
Details can be found in \autoref{s:cobra-sat}.

The main executable, \texttt{cobra}, is a Python script that preprocesses
  the input file and writes the low-level game specification to \texttt{.cobra.in}.
Then it executes \texttt{cobra-backend} and passes on all the options given
  by the user.
Therefore, you can run COBRA on a low-level input format by launching
  \texttt{cobra-backend} directly with the same syntax.

Before \texttt{cobra-backend} finishes, it always outputs a \emph{time overview},
  with information on how much time was spend on which operations and
  how many calls to the SAT solver and to the symmetry breaker has been made.

\begin{figure}[ht]
\begin{lstlisting}
===== TIME OVERVIEW =====
Total time: 74.68s
Bliss (calls/time): 1984 / 0.10s
SAT solvers         sat             fixed           models
* PicoSolver      59 / 0.09s     197  / 0.26s     5635 / 73.23s
\end{lstlisting}
\caption{An example of the time overview after a time demanding task.}
\label{fig:timeoverview}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modes of operation}\label{s:cobra-modes}

\subsection{Overview mode [o, overview] (default)}

\centerline{\texttt{./cobra -m overview <input file> }}
\medskip

Overview mode serves as a basic check that the input file is
  syntactically correct and that the specified game is sensible.
In this mode, the tool prints basic information about the loaded game, such as
  number of variables, number of experiments, size of the search space,
  size of the preprocessed input file,
  trivial bounds on the worst-case and expected-case number of experiments, etc.

It also performs a \emph{well-formed check}, i.e. verifies that the
  specified game is well-formed according to \autoref{def:wellformed}.
Algorithm for the verification follows directly from \autoref{lma:well-formed}.
For each experiment, we verify that
  $\init->\exactlyk{1}(\formx_1, ..., \formx_k)$,
  where $\formx_1,...\formx_k$ are the outcomes of the experiment,
  is a tautology.
This is be done by negating the formula,
  passing it to a SAT solver, asking for satisfiability
  and expecting a negative result.

If a problem is found, the tool outputs an assignment and an experiment
  for which no outcome, or more that one outcome, is satisfied.

\begin{figure}[ht]
\begin{lstlisting}[xleftmargin=.2\textwidth]
Well-formed check... failed!
EXPERIMENT: weighing1 1 2
PROBLEMATIC ASSIGNMENT:
  TRUE: y x3
  FALSE: x1 x2 x4 x5 x6 x7 x8 x9 x10 x11 x12
\end{lstlisting}
\caption{An example of a failed well-formed check in the\\ counterfeit coin problem
 with no ``='' outcome.}
\end{figure}

\subsection{Simulation mode [s, simulation]}

\centerline{\texttt{./cobra -m simulation -e <strategy> -o <strategy> <input file> }}

In the simulation mode, you specify a strategy
  for the codebreaker (for experiment selection)
  and for the codemaker (for outcome selection).
This can be done using \texttt{-e} or \texttt{--codebreaker} switch, and
\texttt{-o} or \texttt{--codemaker} switch, respectively.

Here, the codemaker is not considered a player who chooses
  the secret code in the beginning and then only evaluates experiments,
  but a player who chooses the outcomes
  of the experiments as they come according to his will.
The only condition is that the outcomes are consistent.

\begin{table}[h!]
\begin{center}
\begin{tabular}{|l|p{7cm}|} \hline
COBRA specification & Strategy \\\hline
 \texttt{-e max-models} & Maximal number of models \\
\texttt{-e exp-models} & Expected number of models \\
\texttt{-e ent-models} & Entropy of the number of models \\
\texttt{-e parts} & Number of satisfiable outcomes \\
\texttt{-e min-fixed} & Minimal number of fixed variables \\
\texttt{-e exp-fixed} & Expected number of fixed variables \\\hline
\end{tabular}
\caption{Supported one-step look-ahead strategies for the codebreaker.} \label{tbl:stge}
\end{center}
\end{table}

\begin{table}[h!]
\begin{center}
\begin{tabular}{|l|p{7cm}|} \hline
COBRA specification & Strategy \\\hline
 \texttt{-o models} & Select an outcome with maximal number of models. \\
\texttt{-o fixed} & Select an outcome with minimal number of fixed variables. \\\hline
\end{tabular}
\caption{Supported strategies for the codemaker.} \label{tbl:stgo}
\end{center}
\end{table}

Implemented one-step look-ahead strategies for the codebreaker
  are listed in \autoref{tbl:stge}.
Options for the codemaker are given in \autoref{tbl:stgo}.
Apart from these, the tool supports two extra options for both players,
  \textbf{interactive} and \textbf{random},
  which are not strategies in the sense of \autoref{def:strategy}.

If ``interactive'' is specified as the codebreaker's strategy,
  the tool prints a list of all non-equivalent experiments in each round
  (together with the number of possible outcomes, number of fixed variables
  and number of remaining possibilities) and the user is asked
  to choose the experiment that will be performed.
This effectively allows the user to play the game against a codemaker's strategy.
Similarly, if ``interactive'' is the codemaker's strategy, possible outcomes
  are printed after each experiment and the user is asked to choose one.
Unsatisfiable outcomes are printed as well but are marked accordingly
  and the user cannot select them.

In the random mode, an experiment, or an outcome of an experiment, is
  chosen by random from the list.

The default values for both players are interactive,
  so if you run the simulation mode without any strategy specification,
  you will be first asked to select an experiment and then to select its outcome.

\subsection{Strategy analysis mode [a, analysis]}

\centerline{\texttt{./cobra -m analysis -e <strategy> <input file> }}

In the analysis mode the tool computes
  the worst-case number of experiments and
  the average-case number of experiments needed by
  a given codebreaker's strategy
  to reveal the valution of the variables.

Supported strategy are the same as in the simulation mode and
  can be found in \autoref{tbl:stge}.

The algorithm for this task has been described in \autoref{alg:stganalysis}.
Two variants on the algorithm have been presented,
  one with and one without the symmetry detection.
By default, the symmetry detection in turned on
  but can be turned off with \texttt{--no-symmetry} switch.

\subsection{Optimal strategy mode [ow, optimal-worst, oa, optimal-average]}

\centerline{\texttt{./cobra -m optimal-worst [--opt-bound <double>] <input file> }}
\centerline{\texttt{./cobra -m optimal-average [--opt-bound <double>] <input file> }}

In the optimal strategy mode, the tool computes either the worst-case optimal,
  or the average-case optimal strategy for a given code-breaking game.

The algorithm for this purpose has been described in \autoref{alg:acopt}.
An upper bound can be specified with \texttt{--opt-bound} switch.
In some cases, this can significantly speed up the process.

Note that the optimal strategy synthesis is currently very slow even for
  small instances of code-breaking games.
Further optimizations would be necessary for the tool to synthesise the optimal
  strategy for Mastermind with 4 pegs and 6 colors in a reasonable time.
