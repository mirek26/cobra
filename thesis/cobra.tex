\chapter{COBRA tool}
\label{ch:cobra}
Development of a general tool for analysis of
  code-breaking games is the main part of this work.
We named the tool COBRA, the COde-BReaking game Analyzer.
Currently, it can read a game specification given in a special language, which
  we describe first.
Basic usage is explained afterwords with
  a description of various tasks that the tool can perform with a loaded game.
Notes on dependencies and requirements on external tools,
  on extensibility of COBRA and
  some more implementation detais
  are described in later sections.

Source codes of the tool, together with detailed documentation
  and specification of the games described in \autoref{ch:games}
  can be found in the electronic attachment of the thesis.
A git repository on GitHub\footnote{\url{http://www.github.com}},
  was used during the development,
  so another way of obtaining the code is by cloning
  the repository at \url{https://github.com/myreg/cobra}.
This website also serves as a homepage of the project, and contains
  all related documents.

COBRA is available under \emph{BSD 3-Clause License}\footnote{\url{http://opensource.org/licenses/BSD-3-Clause}},
  text of which is a part of source codes.

\section{Input language}

First we describe the low-level language that is the input format of COBRA.
Next, the language will be equipped with a preprocessor that would allow
  parametrized problem specification and simple formula generation.

\subsection{Low-level language}

The language is directly based on \autoref{def:game}, the formal definition of
  code breaking games.
It is case-sensitive and whitespace is not significant at any position.

\newcommand{\symb}[1]{\;\textcolor{DarkBlue}{\textrm{$<$#1$>$}}\;}
%\newcommand{\txt}[1]{\;\textcolor{DarkRed}{\textsc{#1}}\;}
\newcommand{\txt}[1]{\;\textsc{#1}\;}
\newcommand{\term}[1]{\;\textrm{#1}\;}

Identifier ($\symb{ident}$), is a string starting with a letter or underscore,
  which may contain letters, digits and underscores.
Integer ($\symb{int}$) is a sequence of digits.
String ($\symb{string}$) is any sequence of characters enclosed in quotes.
List of X ($\symb{x-list}$) is a comma-separated list of atoms of type X,
(i.e. generated by grammar $\symb{x-list}::=\symb{x} \| \symb{x-list} , \symb{x}$).

Each line of the input file specifies some part of the game,
  all possibilities are listed in the following table.

\begin{tabular}{|p{.4\textwidth}|p{.55\textwidth}|} \hline
$\txt{Variable} \symb{ident}$ & Declares a variable with a given identifier. \\
$\txt{Variables} \symb{ident-list}$ & Declares variables with given identifiers. \\
$\txt{Restriction} \symb{formula}$ & Defines the initial restriction $\init$. \\
$\txt{Alphabet} \symb{string-list}$ & Defines the parametrization alphabet $\Sigma$. \\
$\txt{Mapping} \symb{ident} \symb{ident-list}$ & Defines a mapping with a given identifier.
  The seconds argument is a list of variable identifiers defining the values of the mapping for all elements of alphabet.    \\
$\txt{Experiment} \symb{string} \symb{int}$ & Opens a section defining a new experiment named by the first argument and having the number of parameter given by the second argument. \\
$\txt{Params-distinct} \symb{int-list}$ & Defines a restriction on the parameters of the experiment,
requiring that parameters at specified positions are different.
This is the only type of allowed restriction. \\
   %\\ \| \txt{Params-sorted} \symb{int-list}
$\txt{Outcome} \symb{string} \symb{formula}$ & Defines an outcome of the experiment. The first parameter is its name, the second is a parametrized formula. \\\hline
\end{tabular} \medskip

We specify what ``formula'' is by the following grammar:
\begin{align*}
\symb{formula} ::=\;
   & \symb{ident$_1$} \| \txt{(} \symb{formula} \txt{)}
      \| \txt{!} \symb{formula} \\
\| & \symb{formula} \circ \symb{formula}
      \| \txt{$X-$} \symb{int$_1$} \txt{(} \symb{formula-list} \txt{)}, \\
\| & \symb{ident$_2$} \txt{(\$} \symb{int$_2$} \txt{)},
\end{align*}
where \symb{ident$_1$} is an identifier of a variable
and $\circ\in\{$and, $\&$, or, $|\:$, --$>$, $<$--, $<$--$>\}$
is a standard logical operator.

$X$ is one of $\atleast{}$, $\atmost{}$, $\exactly{}$ and we call it a \emph{numerical operator}.
Let $X-k(\form_1, ..., \form_n)$ be a formula and consider an valuation under which
  $s$ formulas of $\form_1, ...\form_n$ are satisfied.
Then the formula is satisfied if and only if $s>=k$, $s<=k$ and $s=k$,
  for $X$ being $\atleast{}, \atmost{}$ and $\exactly{}$, respectively.
These operators are non-standard and could be cut out,
  however, they are quite common and useful in specification of code-breaking games
  and their na\"ive expansion to standard operators causes exponential
  blow-up of the size of the formula with respect to $k$.
Hence we support the operators in the language and we handle
  them specifically during the conversion to CNF,
  avoiding the exponential blowup by introduction of new variables.
The conversion is described in detail in \autoref{sec:sat}.

Finally, the last rule allows for formula parametrization.
This can appear only in formulas defining an outcome of an experiment.
$\symb{ident$_2$}$ must be an identifier of a defined mapping and
$\symb{int$_2$}$ must be in the range from 1 to the number of parameters
of the currently defined experiment.

\begin{example}
\TODO{Running example.}
\begin{lstlisting}
VARIABLES y,x1,x2,x3,x4
RESTRICTION Exactly-1(x1,x2,x3,x4)
ALPHABET '1', '2', '3', '4'
MAPPING X x1,x2,x3,x4

EXPERIMENT 'weighing2x2' 4
  PARAMS_DISTINCT 1,2,3,4
  OUTCOME 'lighter' (Or(X$1,X$2) & !y) | (Or(X$3,X$4) & y)
  OUTCOME 'heavier' (Or(X$1,X$2) & y) | (Or(X$3,X$4) & !y)
  OUTCOME 'same' !Or(X$1,X$2,X$3,X$4)
\end{lstlisting}
\end{example}

To parse this language, we use a standard combination of
\emph{GNU Flex}\footnote{\url{http://flex.sourceforge.net/}} for lexical analysis and
\emph{GNU Bison}\footnote{\url{http://www.gnu.org/software/bison/}} for parser generation.
The exact LALR grammar used can be found in $\texttt{cobra.ypp}$ file
  in the source codes.

\subsection{Python preprocessing}

Although the COBRA language is sufficient for our purposes, it is not very user-friendly and
  simple changes in the game may require extensive changes in the file.
For exapmle, if you want to change the number of coins in the Counterfeit Coin problem,
  it would be nice to change only one number in the file
  but now you have to change many lines and create or delete some experiment sections.
The situation is even worse in Mastermind, in which the outcome formulas are
  generated by the algorithm described in \ref{ex:form-mastermind2}.
We would need to write a script or a computer program to generate the input file.

That is exactly why we use a preprocessor to generate the input file.
As the demans may significatnly differ for different games,
  we decided not to create own preprocessing engine
  and use Python\footnote{\url{https://www.python.org}},
  a popular and intuitive scripting languege.

The input can be arbitrary Python file with calls to extra functions
\textsc{Variable}, \textsc{Variables}, \textsc{Restriction}, \textsc{Alphabet},
\textsc{Mapping}, \textsc{Experiment}, \textsc{Params-distinct} and \textsc{Outcome},
which map directly to the constructs in the low-level language.

When we want to generate the low-level input, we simply execute the Python file
and ingest the special functions, that would just print their arguments into
the output file. Types of parameters of these functions are listed below.

\begin{center}
\begin{tabular}{lcc}
 \multicolumn{1}{c}{\textbf{Function}} & \textbf{Type of x} & \textbf{Type of y} \\\hline
\textsc{Variable}(x) & string & - \\
\textsc{Variables}(x) & list of strings & -\\
\textsc{Restriction}(x) & formula as a string& -\\
\textsc{Alphabet}(x) & list of strings & -\\
\textsc{Mapping}(x, y) & string & list of strings\\
\textsc{Experiment}(x, y) & string & integer \\
\textsc{Params-distinct}(x) & list of integers & -\\
\textsc{Outcome}(x, y) & string & formula as a string
\end{tabular}
\end{center}

\begin{example}
An example specification of the counterfeit coin problem follows.
\begin{lstlisting}[language=Python]
N = 12
x_vars = ["x" + str(i) for i in range(N)]
VARIABLES(["y"] + x_vars)
RESTRICTION("Exactly-1(%s)" % ",".join(x_vars))
ALPHABET([str(i) for i in range(N)])
MAPPING("X", x_vars)

# Helper function for disjunction of parameters
# For example, params(2,4) = "X$2 | X$3 | X$4"
params = lambda n0, n1: "|".join("X$" + str(i)
                                 for i in range(n0, n1 + 1))

for m in range(1, N//2 + 1):
  EXPERIMENT("weighing" + str(m), 2*m)
  PARAMS_DISTINCT(range(1, 2*m + 1))
  OUTCOME("lighter", "((%s) & !y) | ((%s) & y)" %
                     (params(1, m), params(m+1, 2*m)))
  OUTCOME("heavier", "((%s) & y) | ((%s) & !y)" %
                     (params(1, m), params(m+1, 2*m)))
  OUTCOME("same", "!(%s)" % params(1, 2*m))
\end{lstlisting}
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation and basic usage}

COBRA is writeen in C++ and uses some features of the modern C++11 standard
  so you need a modern C++ compiler to build the tool.
We have tested and recommend \texttt{gcc} version $4.8$ or higher,
  or \texttt{clang} version $3.2$ or higher.
To compile the tool, run
  \texttt{make}
  in the program folder.
It automatically compiles external tools and builds the necessary libraries.
If everything finishes successfully,
  \texttt{cobra-backend} binary exectuable is created and ready for being used.

The basic syntax to launch the tool is the following.

\medskip
\centerline{\texttt{./cobra [-m <mode>] [-b <backend>] [other options] <input file>}}
\medskip


Mode of operation, specified by \texttt{-m} switch,
  specifies what will the tool do with the game.
Posibilities are described in the \autoref{s:cobra-modes}, together with description
  of other options, that differ for different modes.
Backend, specified by \texttt{-b} switch, specifies which backend should be
  used for SAT solving and model counting.
In most cases, you should be fine with the default backend and can ignore this option.
Details can be found in \autoref{s:cobra-sat}.

\texttt{cobra} is a Python script that preprocesses the input file and writes
the low-level input to \texttt{.cobra.in}.
Then it executes \texttt{cobra-backend} and passes all the options given to \texttt{cobra}.
Thus, if you want to run cobra on a low-level input format, you can run
  \texttt{cobra-backend} directly.

Before \texttt{cobra-backend} finishes, it always outputs a \emph{time overview},
with information on how much time was spend on which operations.

\begin{lstlisting}
===== TIME OVERVIEW ======
Total time: 42s.
Bliss: ...
SAT: ...
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modes of operation}\label{s:cobra-modes}

\subsection{Overview mode [o, overview] (default)}

\centerline{\texttt{./cobra -m overview <input file> }}
\medskip

Overviwe mode serves as a basic check that your input file is
  syntactically correct and that the game you specified is sensible.

In this mode, the tool prints basic information about the loaded game, such as
  number of variables, number of experiments, size of the search space,
  size of the preprocessed input file,
  trivial bounds on the worst-case and expected-case number of experiments, etc.

It also performs a \emph{well-formed} check, i.e. verifies that the
  specified game is well-formed according to \autoref{def:wellformed}.

Verification that an experiment with outcomes $\formx_1,...\formx_k$ is well-formed
  can be done by verifying that $\init->\exactly{1}(\formx_1, ..., \formx_k)$
  is a tautology.
We negate the formula, pass it to a SAT solver, ask for satisfiability and expect a negative result.

Verification that the game is well-formed is done by
  generating possible non-equivalent experiments for the first round
  and verifying that all of them are well-formed.
This is enough thanks to \autoref{lma:exp-wellformed}
\TODO{Lemma: pokud jsou experimenty ekviv a jeden je well-formed, je i druhy well-formed.}
If a problem is found, the tool outputs an assignment and an experiment
  for which no outcome, or more that one outcome, is satisfied.

\subsection{Simulation mode [s, simulation]}

\centerline{\texttt{./cobra -m simulation -1 <strategy> -2 <strategy> <input file> }}

In the simulation mode, you specify a strategy for
  the codebreaker and for the codemaker.
This can be done using \texttt{-1} or \texttt{--codemaker} switch, and
\texttt{-2} or \texttt{--codebreaker} switch, respectively.

Here, we do not consider the codemaker as a player who just chooses the codes
and evaluates experiments, but as a player who chooses the outcomes
of experiments accroding to his will.
The only condition is, that he must be consistent.

Implemented strategies for both codebreaker and codemaker
  are described in the next section and mostly correspond to strategies
  that can be found in the literature on Mastermind.
Apart from these, the tool supports two extra options, \textbf{interactive}
  and \textbf{random}, which are not strategies in the sense of \autoref{def:strategy}.

If ``interactive'' is specified as the codebreaker's strategy,
  the tool prints a list of all non-equivalent experiments
  (together with the number of posiible outcomes, number of fixed variables
  and number of remaing possibilities) and the user is asked
  to choose the experiment that would be performed.
This effectively allows the user to play the game against a codemaker's strategy.

Similarly, is ``'interactive'' is codemaker's strategy, possible outcomes
  are printed after each experiment and the user is asked to choose one.
Unsatisfiable outcomes are printed as well but are marked as such and
  the user cannot choose them.

In the random mode, an experiment, or an outcome of an experiment, is
  choosen by random from the list.

The default values for both codemaker and codebreaker are interactive,
  so if you run the simulation mode without strategy specification,
  you will be asked both to select experiments and to select the outcome.

\subsection{Strategy analysis mode [a, analysis]}

\centerline{\texttt{./cobra -m analysis -2 <strategy> <input file> }}

This makes the tool compute worst-case number of experiments and
average-case number of experiments for a given codebreaker's strategy.

\TODO{pseudocode?}

\subsection{Optimal strategy mode [o, optimal]}
\TODO{...}


\section{Strategies}

\subsection{Codebreaker's strategy}

We support the following one-step look-ahead strategies for the codebreaker.
Let $N$ denote the number of possible codes in the current state,
and for a fixed experiment, let $n_i$ denote number of possible codes that
will end up in outcome $i$.

\begin{description}
\item[Min-num.] \texttt{-2 minnum} \\
  Minimizes the worst-case number of remaining codes
  in the next step, i.e. selects experiment with minimal $\max_i n_i$.
  For Mastermind, this was suggested by Knuth\cite{mm-knuth}.
\item[Min-exp.]  \texttt{-2 minexp} \\
   Minimizes the expected number of remaining codes
  in the next step, i.e. minimize $\sum_in_i^2/N$.
  For Mastermind, this was suggested by Irwing\cite{mm-expnum}.
\item[Entropy.] \texttt{-2 entropy} \\
  Maximizes the entropy of numbers of remaining codes,
  i.e. maximizes $-log(k_i)\cdot k_i$, where $k_i=n_i/N$.
  For Mastermind, this was suggested by Neuwirth\cite{mm-entropy}.
\item[Most-parts.] \texttt{-2 parts} \\
  Maximizes the number of possible outcomes,
  i.e. maximize $\# i. (n_i > 0)$.
  For Mastermind, this was suggested by Kooi\cite{mm-mostparts}.
\item[Fixed.] \texttt{-2 fixed} \\
  Maximize the number of fixed variables
  in the next step.
  This is specific to propositional logic representation of a code-breaking game.
  Further, it depands on the exact formalization.
  For example, though Examples \ref{ex:form-fake-coin1}
  and \ref{ex:form-fake-coin2} both describe the same problem,
  the choice of the experiment by the \emph{fixed} strategy is
  different in the very first step.
% TODO: SAt resolutions, ... ? (jine vlastni)
\end{description}

\subsection{Codemaker's strategy}

The codemaker has the following strategy options.
Note that none of them is guaranteed to maximize the
  number of experiments of any codebreaker's strategy.

\begin{description}
\item[Max-num.] \texttt{-1 maxnum} \\
  Select an outcome with largest $n_i$. This
  corresponds to the \emph{min-num} strategy for codebreaker.
\item[Fixed.] \texttt{-1 fixed} \\
  Minimizes the number of fixed variables in the next step.
\end{description}

\subsection{Extensibility}

If you want to analyze a new heuristics to selects experiments,
  all you need to do is to implement a new function
  in \texttt{strategy.h/strategy.cpp} file and add a corresponding entry
  to the \texttt{...} table in \texttt{strategy.h}.
A strategy function takes a list of sensible experiments as a parameter
  and it should return the index of the selected one.

If your strategy only \emph{maximizes} or \emph{minimizes}
  some metrics on the experiments,
  you can even use a template provided with a corresponding lambda function.
As an example, we show the exact implementation of the \emph{Min-exp} strategy.
For exact details, see the documentation in the file.

\begin{lstlisting}[language=C++]
uint breaker::exp_num(vec<Option>& options) {
  return minimize([](Option& o){
    auto models = o.GetNumOfModels();
    int sumsq = 0;
    for (uint i = 0; i < o.type().outcomes().size(); i++) {
      sumsq += models[i] * models[i];
    }
    return (double)sumsq / o.GetTotalNumOfModels();
  }, options);
}
\end{lstlisting}

