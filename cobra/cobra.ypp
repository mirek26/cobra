/*
 * Copyright 2013, Mirek Klimos <myreggg@gmail.com>
 */
%{
  #include <iostream>
  #include <cstdlib>
  #include <cctype>
  #include <cstring>
  #include <string>
  #include <vector>

  #include "formula.h"
  #include "ast-manager.h"
  #include "game.h"

  #define YYERROR_VERBOSE
  extern "C" int yylex();
  extern "C" int yyparse();
  extern "C" int yylineno;
  extern "C" char* yytext;
  void yyerror (const char *error);

  extern AstManager m;
%}

%token T_IDENT
%token T_INT
%token T_STRING

/* order of precedence from
 * http://en.wikipedia.org/wiki/Logical_connective#Order_of_precedence
 */
%right T_EQUIV
%right T_IMPLIES
%left T_IMPLIED
%right T_OR
%right T_AND
%right T_NOT

%token T_ATLEAST
%token T_ATMOST
%token T_EXACTLY
%token T_VARS
%token T_INIT
%token T_EXP

%union {
  Formula* formula;
  Variable* variable;
  std::vector<Formula*>* formula_list;
  std::vector<Variable*>* variable_list;
  Parametrization* param_range;
  char*    tstr;
  int      tint;
}

/* Lets inform Bison about the type of each terminal and non-terminal */
%type <tstr>     T_IDENT
%type <tstr>     T_STRING
%type <tint>     T_INT
%type <formula>  formula
%type <formula_list> formula_list
%type <variable> variable
%type <variable_list> variable_list
%type <variable_list> variable_range
%type <param_range> param_range
%%

definition :
    assignment
  | definition assignment

assignment :
    T_VARS '=' '{' variable_list '}'
    {  m.setVars($4);  }
  | T_INIT '=' formula
    {  m.setInit($3);  }
  | T_EXP '(' T_STRING ',' param_range ')' '{' formula_list '}'
    {  m.addExp(m.get<Experiment>($3, $5, $8)); }

variable :
    T_IDENT
      { std::string x($1); $$ = m.get<Variable>(x); }
  | T_IDENT T_INT
      { std::string x($1); $$ = m.get<Variable>(x, $2); }

variable_range :
    variable '.' '.' variable
      { $$ = m.getVariableRange($1, $4); }

variable_list :
    variable
      { $$ = new std::vector<Variable*>({ $1 }); }
  | variable_range
      { $$ = $1; }
  | variable_list ',' variable
      { $$->push_back($3); }
  | variable_list ',' variable_range
      { $$->insert($$->begin(), $3->begin(), $3->end());
        delete $3; }

param_range_single:
    '{' variable_list '}'
      { }
  | '{' variable_list '}' '^' T_INT
      { }

param_range :
     param_range_single
      { }
  |  param_range param_range_single
      { }

formula :
    '(' formula ')'
      { $$ = $2; }
  | formula T_AND formula
      { $$ = m.get<AndOperator>($1, $3); }
  | formula T_OR formula
      { $$ = m.get<OrOperator>($1, $3); }
  | formula T_IMPLIES formula
      { $$ = m.get<ImpliesOperator>($1, $3); }
  | formula T_IMPLIED formula
      { $$ = m.get<ImpliesOperator>($3, $1); }
  | formula T_EQUIV formula
      { $$ = m.get<EquivalenceOperator>($1, $3); }
  | T_ATLEAST '-' T_INT '(' formula_list ')'
      { $$ = m.get<AtLeastOperator>($3, $5); }
  | T_ATMOST '-' T_INT '(' formula_list ')'
      { $$ = m.get<AtMostOperator>($3, $5); }
  | T_EXACTLY '-' T_INT '(' formula_list ')'
      { $$ = m.get<ExactlyOperator>($3, $5); }
  | T_AND '(' formula_list ')'
      { $$ = m.get<AndOperator>($3); }
  | T_OR '(' formula_list ')'
      { $$ = m.get<OrOperator>($3); }
  | T_NOT formula
      { $$ = m.get<NotOperator>($2); }
  | variable
      { $$ = $1; }

formula_list :
    formula
      { $$ = new std::vector<Formula*>({ $1 }); }
  | formula_list ',' formula
      { $1->push_back($3); }
  | variable_range
      { $$ = new std::vector<Formula*>();
        $$->insert($$->begin(), $1->begin(), $1->end()); }

%%

void yyerror(const char *error)
{
  printf("%d: %s at %s\n", yylineno, error, yytext);
 // std::cout << error << std::endl;
}