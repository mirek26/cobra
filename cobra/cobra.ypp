/*
 * Copyright 2013, Mirek Klimos <myreggg@gmail.com>
 */
%{
  #include <iostream>
  #include <cstdlib>
  #include <cctype>
  #include <cstring>
  #include <string>
  #include <vector>

  #include "./formula.h"
  #include "./ast-manager.h"

  #define YYERROR_VERBOSE
  extern "C" int yylex();
  extern "C" int yyparse();
  void yyerror (const char *error);

  extern AstManager m;
%}

%token T_IDENT
%token T_INT

/* order of precedence from
 * http://en.wikipedia.org/wiki/Logical_connective#Order_of_precedence
 */
%right T_EQUIV
%right T_IMPLIES
%left T_IMPLIED
%right T_OR
%right T_AND
%right '!'

%token T_ATLEAST
%token T_ATMOST
%token T_EXACTLY

%union {
  Formula* formula;
  std::vector<Formula*>* list_of_formulas;
  char*    tstr;
  int      tint;
}

/* Lets inform Bison about the type of each terminal and non-terminal */
%type <formula>  formula
%type <tstr>     T_IDENT
%type <tint>     T_INT
%type <list_of_formulas> list_of_formulas

%%

formula :
    '(' formula ')'
      { $$ = $2; }
  | formula T_AND formula
      { $$ = m.get<AndOperator>($1, $3); }
  | formula T_OR formula
      { $$ = m.get<OrOperator>($1, $3); }
  | formula T_IMPLIES formula
      { $$ = m.get<ImpliesOperator>($1, $3); }
  | formula T_IMPLIED formula
      { $$ = m.get<ImpliesOperator>($3, $1); }
  | formula T_EQUIV formula
      { $$ = m.get<EquivalenceOperator>($1, $3); }
  | T_ATLEAST '-' T_INT '(' list_of_formulas ')'
      { $$ = m.get<AtLeastOperator>($3, $5); }
  | T_ATMOST '-' T_INT '(' list_of_formulas ')'
      { $$ = m.get<AtMostOperator>($3, $5); }
  | T_EXACTLY '-' T_INT '(' list_of_formulas ')'
      { $$ = m.get<ExactlyOperator>($3, $5); }
  | '!' formula
      { $$ = m.get<NotOperator>($2); }
  | T_IDENT
      { std::string x($1); $$ = m.get<Variable>(x); }

list_of_formulas :
    formula    { $$ = new std::vector<Formula*>({ $1 }); }
  | list_of_formulas ',' formula { $1->push_back($3); }

%%

void yyerror(const char *error)
{
  std::cout << error << std::endl;
}