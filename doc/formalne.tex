\chapter{Code-breaking Games}

% znaceni
\newcommand{\Val}{V} % mnoz vsech valuaci
\newcommand{\val}{v} % jedna valuace
\newcommand{\numval}{\tau} % number of sat valutaions
\renewcommand{\Form}{\textrm{Form}} % mnoz vsech formuli
\newcommand{\form}{\varphi} % jedna formule
\newcommand{\aform}[1]{\form_{0..#1}} % accumulated formula

% code-breaking game
\newcommand{\game}{\mathcal{G}}
\newcommand{\Var}{X}
\newcommand{\init}{\varphi_0}
\newcommand{\Expt}{T}
\newcommand{\expt}{t}
\newcommand{\Exp}{E}
\renewcommand{\exp}{e}
%\newcommand{\Param}{\Pi}
\newcommand{\param}{p}
\newcommand{\infer}{\Phi}

% dalsi veci
\newcommand{\Perm}{\textrm{Perm}}
\newcommand{\perm}{\pi}
\newcommand{\result}{\rho}

% nep
\newcommand{\stg}{\sigma}

\newcommand{\proc}{\pi}
\newcommand{\procstg}[2]{\proc_{#1,#2}}

\newcommand{\len}{\lambda}
\newcommand{\lenstg}[2]{\len^{#1,#2}}
\newcommand{\lenmax}[1]{\len^{#1}}
\newcommand{\lenexp}[1]{\len^{#1}_\textrm{exp}}

\newcommand{\exactly}[1]{\textrm{Exactly-#1}\:}
\newcommand{\atleast}[1]{\textrm{AtLeast-#1}\:}
\newcommand{\atmost}[1]{\textrm{AtMost-#1}\:}

\section[0]{Notation}
Let $\Form_\Var$ be the set of all prepositional formulas over
  the set of variables $\Var$;
  $\Val_\Var$ be the set of all valuations of variables $\Var$.
Formulas $\form_0, \form_1 \in \Form_\Var$ are (semantically) equivalent,
  written $\form_0 \equiv \form_1$, if
  $\val(\form_0) = \val(\form_1)$ for all $\val\in\Val_\Var$.
For a formula $\form\in\Form_\Var$, let
  $\numval_\Var(\form) = |\{ \val\in\Val_\Var \| \val(\form) = 1 \}|$
  be the number of valuations by which $\form$ is satisfied.
We often omit the index $\Var$ if it is clear from the context.

For any unary predicate $P$, $\#i\in A.P(i) = |\{ i\in A \| P(i)\}|$.
  We often omit the ``$\in A$'' part and write only $\#i.P(i)$
  if the range of $i$ is clear from the context.

Let $\Perm_\Var$ be the set of all permutations of $\Var$.

%-------------------------------------------------------------------------------
% DEF: CODE BREAKING GAME
\section{Formal definition}
\begin{definition} \label{def-game}
A \emph{code-breaking game} is a quintuple
  $\game = (\Var, \init, \Expt, \Exp, \infer)$, where
  \begin{itemize}
  \item $\Var$ is a finite set of propositional variables,
  \item $\init \in \Form_\Var$ is a satisfiable prepositional formula,
  \item $\Expt$ is a finite set of types of experiments,
  \item $\Exp \subseteq \Expt \times \Var^\star$ is an \emph{experiment} relation,
  and
  \item $\infer: \Exp -> 2^{\Form_\Var}$ is an
  \emph{outcome function} such that $\infer(\exp)$ is finite
  for any $\exp\in\Exp$, (and for $\infer(\exp) = \{\psi_1, ..., \psi_k\}$,
  it holds
  \[
  \forall\val\in\Val_\Var:  \val(\init) = 1 ==> \exists\psi\in\infer(\exp)\;.\; \val(\psi) = 1
  \]
  i.e. $\init ==> \psi_1 \vee \psi_2 \vee ... \vee \psi_k$ is true.

 \end{itemize}
\end{definition}

Intuitively, the objective of the game is to find a valuation of
  variables $\Var$ by a series of experiments.
Let us call it \emph{the wanted valuation}.
The search space is reduced by formula $\init$,
  which is always known to be satisfied by the wanted valuation.

Experiments consist of a type, which is from the set $\Expt$ and a
  parametrization, which is a string of variables from $\Var$.
The experiment relation $\Exp$ specifies all permitted parameterizations
  for each type of experiment and, therefore, $\Exp$ is the set of
  all possible experiments as pairs.

The outcome function gives us the possible outcomes of an experiment.
  We require that at least one of them must be satisfied by every valuation
  by which $\init$ is satisfied.


%-------------------------------------------------------------------------------
% EXAMPLE: FAKE-COIN PROBLEM

\begin{example}[Fake-coin problem]
Fake-coin problem with $n$ coins, one of which is fake, can be formalized as
a code breaking game
$\mathcal{F}_n = (\Var, \init, \Expt, \Exp, \infer)$, where

\begin{itemize}
\item
$\Var = \{x_1, x_2, ..., x_n, y\}$ \\
Intuitively, variable $x_i$ tells weather the coin $i$ is fake.
Variable $y$ tells weather it's lighter or heavier.

\item
$\init = \exactly{1}(\{x_1, ..., x_n\})$ \\
This is to ensure that exactly one coin is fake.

\item
$\Expt = \{\expt\}$ \\
There is only one type of experiment -- weighting the coins.

\item
$\Exp = \{ (\expt, \param) \|
  \param \in \{x_1, ..., x_n\}^{2n},
  n >= 0,
  \forall x\in\Var: \#_x(\param)<=1 \} $\\
Any sequence of variables of even length with no repetitions
  is a permitted parametrization of type $\expt$.

\item
\begin{align*}
\infer((\expt, \param)) = \big\{
& (\bigvee A \wedge \neg y) \vee (\bigvee B \wedge y), \\
& (\bigvee A \wedge y) \vee (\bigvee B \wedge \neg y), \\
& \neg \bigvee(A\cup B) \big\},
\end{align*}
where
$A = \{ \param[i] \| 1 <= i <= |\param|/2 \}$,
$B = \{ \param[i] \| |\param|/2 < i <= |\param| \}$.
\end{itemize}
\end{example}

%-------------------------------------------------------------------------------
% EXAMPLE: MASTERMIND

\begin{example}[Mastermind]
Mastermind puzzle with $n$ pegs and color set $C$ can be formalized as
a code breaking game
$\mathcal{M}_{n,C} = (\Var, \init, \Expt, \Exp, \infer)$, where

\begin{itemize}
\item
$\Var = \{x_{i,c} \| 1<=i<=n, c\in C\}$. \\
Variable $x_{i,c}$ tells whether there is the color $c$ at position $i$.
For simplicity, let us use the notation $\Var_c = \{ x_{i,c} \| 1<=i<=n \}$.

\item
$\init = \bigwedge\left\{
  \exactly{1} \{x_{i,c} \| c\in C\} \| 1<=i<=n\right\}$. \\
This guarantees that there is exactly one color at each position.

\item $\Expt = \{\expt\}$.\\
There is only one type of experiment -- guessing a combination.

\item $\Exp = \{(\expt, \param) \| \param = x_{1,c_1}x_{2,c_2}...x_{n,c_n}\}$.\\
Parametrization of $\expt$ can be any string of length $n$,
$i$-th symbol of which belongs to $\{ x_{i,c} \| c \in C\}$.

\item Inference function is defined by
\begin{align*}
\infer(\val, (\expt, \param)) =\;
 & \exactly{b}\{ \param[i] \| 1<=i<=n \} \;\wedge \\
 & \exactly{t}\bigcup
      \big\{ \\
          & \{
                \atleast{k}\{ x_{i,c} \| 1<=i<=n \}
                \| 1 <= k <= \#i.(\param[i]\in\Var_c)
            \} \\
            & \| c\in C
      \big\}
\end{align*}
where $b = \# i . (\val(\param[i]) = 1)$ captures the number of black pegs
  in the response for the experiment $(t, p)$ and
  $t = \sum_{c\in C} \min( \#i.(v(x_{i,c}) = 1), \#i.(\param[i]\in\Var_c))$
  is the total number of pegs (black + white).

% TODO:
\TODO{Fakt to nejde nějak jednodušej?}
\end{itemize}
\end{example}

%-------------------------------------------------------------------------------
% DEF: STRATEGY
\section{Strategies}

\begin{definition}
A \emph{strategy} is a function $\stg: \Form_\Var -> \Exp$,
determining the next experiment for given accumulated knowledge,
such that
\[
\form_0 \equiv \form_1 ==> \stg(\form_0) = \stg(\form_1).
\]
\end{definition}

A strategy $\stg$ together with a secret valuation $\val$ induce
  a \emph{solving process}, which is an infinite sequence
\[
\procstg{\stg}{\val} = \form_0 \arrow{\exp_1} \form_1 \arrow{\exp_2}
  \form_2 \arrow{\exp_3} ...
\]
such that
$\exp_{i+1} = \stg(\form_0 \wedge \form_1 \wedge ... \wedge \form_i)$ and
$\form_{i+1} = \infer(\val, \exp_{i+1})$ for all $i\in\Nseto$.
For the sake of simplicity, let us write $\aform{k}$
instead of $\form_0 \wedge \form_1 \wedge ... \wedge \form_k$.

We define \emph{length} of the solving process,
  denoted $|\procstg{\stg}{\val}|$
  (despite the infinite length of the sequence),
  as the smallest $k\in\Nseto$ such that
  $\numval_\Var(\aform{k}) = 1$.
This corresponds to the situation in which we can unambiguously
  determine the secret code.

Note that it always holds $\numval(\aform{k}) > 0$ because
  $\val(\aform{k}) = 1$ thanks to the condition (i)
  in Definition \ref{def-game}.

The following lemma is a straightforward consequence
  of the memory-less nature of the games. It says that once a strategy
  gives us an experiment that yields no new information, we will never more get
  any new information (using the strategy).

\begin{lemma}
If $\numval(\aform{k}) = \numval(\aform{k+1})$ for some $k\in\Nset$,
then $\numval(\aform{k}) = \numval(\aform{k+l})$ for any $l\in\Nset$.
\end{lemma}

\begin{proof}
If $\aform{k+1} = \aform{k} \wedge \form_{k+1}$
is satisfied by valuation $\val$, so must be $\aform{k}$.
Since $\numval(\aform{k}) = \numval(\aform{k+1})$, the sets of
valuations satisfying $\aform{k}$ and $\aform{k+1}$ must be exactly the same
and the formulas are thus equivalent. This implies
$\stg(\aform{k}) = \stg(\aform{k+1})$ and thus also $\form_{k+2} = \form_{k+1}$.
By induction, $\form_{k+l} = \form_{k+1}$ and $\aform{k+l} \equiv \aform{k}$
 for any $l\in\Nset$.\qed
\end{proof}

The \emph{worst-case number of experiments} $\lenmax{\stg}$
  of a strategy $\stg$ is the maximal length of the solving process
  $\procstg{\stg}{\val}$ over all valuations $\val$, i.e.
  $\lenmax{\stg} = \max_{\val\in\Val_\Var} |\procstg{\stg}{\val}|$.
We say that the strategy \emph{solves the game} if $\lenmax{\stg}$ is finite.
The game is \emph{solvable} if there exists a strategy that solves the game.

\begin{problem}
Given a code-breaking game $\game$, decide whether $\game$ is solvable.
\end{problem}

\begin{definition}
A strategy $\stg$ is \emph{optimal} if
  $\lenmax{\stg} <= \lenmax{\stg'}$ for any strategy $\stg'$.

A strategy $\stg$ is \emph{greedy} if
  for every $\form\in\Form_X$ and $\exp'\in\Exp$,
\[
\max_{\val\in\Val_\Var} \numval_\Var(\form \wedge \infer(\val, \stg(\form))) <=
\max_{\val\in\Val_\Var} \numval_\Var(\form \wedge \infer(\val, \exp')).
\]
In words, a greedy strategy minimizes
  the worst-case number of possible valuations in the next step.
\end{definition}

\begin{problem}
Given a code-breaking game $\game$,
  decide whether all greedy strategies are optimal.
This seems to be the case for Fake-coin problem (?)
  but it is not the case for Mastermind[ref].
\end{problem}
